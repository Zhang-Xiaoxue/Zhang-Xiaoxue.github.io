<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/Academy-favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Academy-favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/Academy-favicon.png">
  <link rel="mask-icon" href="/images/Academy-favicon" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;zhang-xiaoxue.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;right&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script>
<meta property="og:type" content="website">
<meta property="og:title" content="Xiaoxue Zhang - NUS">
<meta property="og:url" content="https://zhang-xiaoxue.github.io/page/3/index.html">
<meta property="og:site_name" content="Xiaoxue Zhang - NUS">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Xiaoxue Zhang">
<meta property="article:tag" content="Reinforcement Learning, Optimization and Control, Intellegent Systems">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhang-xiaoxue.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;en&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;3&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Xiaoxue Zhang - NUS</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Xiaoxue Zhang - NUS</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">NUS Ph.D.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Xiaoxue Zhang"
      src="/images/photo_blue.jpg">
  <p class="site-author-name" itemprop="name">Xiaoxue Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Zhang-Xiaoxue" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Zhang-Xiaoxue" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xiaoxuezhang@u.nus.edu" title="E-Mail → mailto:xiaoxuezhang@u.nus.edu" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.linkedin.com/in/xiaoxue-zhang-5233b611a/" title="https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;xiaoxue-zhang-5233b611a&#x2F;" rel="noopener" target="_blank">Linkedin</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.zhihu.com/people/lisnol" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;lisnol" rel="noopener" target="_blank">知乎</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Zhang-Xiaoxue" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhang-xiaoxue.github.io/2020/06/30/Reinforcement%20Learning/Normalizing%20flow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/photo_blue.jpg">
      <meta itemprop="name" content="Xiaoxue Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiaoxue Zhang - NUS">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/30/Reinforcement%20Learning/Normalizing%20flow/" class="post-title-link" itemprop="url">Normalizing Flow</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-06-30 12:00:00" itemprop="dateCreated datePublished" datetime="2020-06-30T12:00:00+08:00">2020-06-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-08-16 15:22:36" itemprop="dateModified" datetime="2021-08-16T15:22:36+08:00">2021-08-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Reinforcement-Learning/" itemprop="url" rel="index"><span itemprop="name">Reinforcement Learning</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Normalizing-flow"><a href="#Normalizing-flow" class="headerlink" title="Normalizing flow"></a>Normalizing flow</h1><h2 id="Research-Gap："><a href="#Research-Gap：" class="headerlink" title="Research Gap："></a>Research Gap：</h2><p>现有研究（GAN，VAE， DRAW等deep generative models）不容易进行测试解析（如概率密度不可得）和度量（如KL距离，earth-mover距离不可得） 。</p>
<p>目标：分布既能表达真实样本又有传统统计学习所具备的的较好的解释性</p>
<p>Guassian distribtion：采样方便，解析密度可知，KL距离容易计算，“中心极限定理”（任何大数据最终区域Guassian distribution），参数化技巧，提督反转等优点。但真实样本的PDF往往与categorical distribution或者Guassian distribution的差距很大，分布不够集中出现边缘效应，不能应对罕见事物等缺点。</p>
<p>要求：</p>
<ul>
<li>足够复杂，容得下多个模式，比如增强学习中的图像和评分函数； </li>
<li>足够简单，能采样，能估计密度，能重参数化。</li>
</ul>
<p>Idea：</p>
<p>使用一个简单的概率分布，从它采样，再对samples作变换（等价于改不变概率分布）。如果让这个变换满足某些milde condition，应该可以得到一个关于变换后的随机变量的非常复杂的PDF。–&gt;得到一个可逆，可计算分布变换，易模拟的模型 –&gt; normalizing flow</p>
<p>意义：</p>
<ul>
<li>把简单分布（如Gaussian分布）的PDF转化成某种复杂分布。这里的flow值的是data glow经过一系列双射（可逆映射），最终可映射到合适的representative space；normalizing值的事representative space的变量积分为1（这也满足PDF的概念）。</li>
<li>可产生复杂的分布函数，用于reinforcement learning、generative model、variational inference等。</li>
</ul>
<h2 id="Normalizing-flow介绍："><a href="#Normalizing-flow介绍：" class="headerlink" title="Normalizing flow介绍："></a>Normalizing flow介绍：</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1graw80uticj30g707rmxx.jpg"></p>
<p>Geerative models with tractable explicit density 值的是$p(x)$可以直接计算出来，包括了大部分auto regressive model (NADE, MADE, PixelRNN/CNN)，还包括flow-based model（通过变量替换，用$p(z)$通过变换得到$p(x)$，即$x=T(z)$。</p>
<p>Flow-based model:</p>
<ul>
<li>likelihood based</li>
<li>change of variable (采用变量替换的方式解决因变量问题)</li>
<li>tractable（可精确infer $p(x;\theta)$</li>
</ul>
<h2 id="具体推导："><a href="#具体推导：" class="headerlink" title="具体推导："></a>具体推导：</h2><p>flow-based model：需要多个简单变换的复合来增强拟合能力$T = T_k \circ \cdots \circ T_1$，且简单变换$T_i$的逆与微分都满足可乘性。得到的分布由base distribution和双射函数得到：</p>
<ol>
<li>base distribution：可以是gaussian 分布, <code>base_dist()</code></li>
<li>双射函数：<ol>
<li>前向映射 $x=T(u)$, <code>X=bijector.forward(base_dist.saple())</code></li>
<li>反向映射 $u=T^{-1}(x)$, <code>J=new_dist.log_prob(bijector.inverse(x))+bijector.inverse_log_det_jacobian(x)</code>, <code>x</code>是样本。</li>
<li>Jacobian矩阵的逆对数行列式 $\log(|\operatorname{det}(J(T^{-1}(x)))|)$. 用于评估转换后分布的对数密度。算法通过最大似然估计，把拟合真实数据的分布问题变成拟合变换后的概率的对数密度问题</li>
</ol>
</li>
</ol>
<p>在神经网络中，取决于模型任务的不同，部分双射函数可以只实现前向映射$T_k$或后向映射$T_k^{-1}$中的一个。我们用$f_{\phi_k}$表示带有参数$\phi_k$的双射函数层，多个这类简单变换构成的双射函数层复合，成为流模型。</p>
<p>目标函数：$\log(p_X(x_n)) = \log(p_u(T^{-1}(x_n))) + \log(|\operatorname{det}(J(T^{-1}(x_n)))|^{-1})$. 可以用KL divergence和Monte Carlo方法的无偏估计得到：</p>
<ol>
<li><p>正向KL divergence<br>$$<br>\begin{aligned}<br>\mathcal{L}(\boldsymbol{\theta}) &amp;=D_{\mathrm{KL}}\left[p_{\mathrm{x}}^{<em>}(\mathrm{x}) | p_{\mathrm{x}}(\mathrm{x} ; \theta)\right] \<br>&amp;=-\mathbb{E}<em>{p</em>{\mathrm{x}}^{</em>}(\mathrm{x})}\left[\log p_{\mathrm{x}}(\mathrm{x} ; \theta)\right]+\mathrm{const.} \<br>&amp;=-\mathbb{E}<em>{p</em>{\mathrm{x}}^{<em>}(\mathrm{x})}\left[\log p_{\mathrm{u}}\left(T^{-1}(\mathrm{x} ; \phi) ; \psi\right)+\log \left|\operatorname{det} J_{T^{-1}}(\mathrm{x} ; \phi)\right|\right]+\mathrm{const} .<br>\end{aligned}<br>$$<br>如果我们拥有真实样本$x_n\sim p^</em>(x)$，用Monte Carlo简化后，有<br>$$<br>\mathcal{L}(\boldsymbol{\theta}) \approx-\frac{1}{N} \sum_{n=1}^{N} \log p_{\mathrm{u}}\left(T^{-1}\left(\mathbf{x}<em>{n} ; \boldsymbol{\phi}\right) ; \boldsymbol{\psi}\right)+\log \left|\operatorname{det} J</em>{T^{-1}}\left(\mathbf{x}_{n} ; \boldsymbol{\phi}\right)\right|+\text { const. }<br>$$<br>当目标分布$p^*(x)$的真实样本可以得到但PDF无法计算出来时，evaluate这个model只需要用到$T^{-1}$和$\operatorname{det}(J(T^{-1}))$，而不用计算$T$与$p(u)$也可以训练model，但是如果我们想在训练好的模型上生成新的样本，$T$与$p(u)$也仍然需要.</p>
<p>在具体的实践中，我们可以通过采用梯度下降的方法最小化损失函数$\mathcal{L}(\boldsymbol{\theta})$:<br>$$<br>\begin{array}{l}<br>\nabla_{\phi} \mathcal{L}(\theta) \approx-\frac{1}{N} \sum_{n=1}^{N} \nabla_{\phi} \log p_{u}\left(T^{-1}(\mathbf{x} n ; \phi) ; \psi\right)+\nabla \phi \log \left|\operatorname{det} J_{T^{-1}}(\mathbf{x} n ; \phi)\right| \<br>\nabla \psi \mathcal{L}(\theta) \approx-\frac{1}{N} \sum_{n=1}^{N} \nabla_{\psi} \log p_{u}\left(T^{-1}\left(\mathbf{x}_{n} ; \phi\right) ; \psi\right)<br>\end{array}<br>$$</p>
</li>
<li><p>反向KL divergence</p>
<p>当我们拥有真实样本$p^*$的分布，但很难得到真实样本分布的采样$x_n$时，可以通过反向KL divergence来评估模型，具体的到做事通过变量替换，对$x$的操作转换成对$u$的操作：<br>$$<br>\begin{aligned}<br>\mathcal{L}(\boldsymbol{\theta}) &amp;=D_{\mathrm{KL}}\left[p_{\mathrm{x}}(\mathbf{x} ; \boldsymbol{\theta}) | p_{\mathrm{x}}^{<em>}(\mathbf{x})\right] \<br>&amp;=\mathbb{E}<em>{p</em>{\mathrm{x}}(\mathbf{x} ; \boldsymbol{\theta})}\left[\log p_{\mathrm{x}}(\mathbf{x} ; \boldsymbol{\theta})-\log p_{\mathrm{x}}^{</em>}(\mathbf{x})\right] \<br>&amp;=\mathbb{E}<em>{p</em>{\mathrm{u}}(\mathbf{u} ; \psi)}\left[\log p_{\mathrm{u}}(\mathbf{u} ; \boldsymbol{\psi})-\log \left|\operatorname{det} J_{T}(\mathbf{u} ; \boldsymbol{\phi})\right|-\log p_{\mathrm{x}}^{<em>}(T(\mathbf{u} ; \boldsymbol{\phi}))\right]<br>\end{aligned}<br>$$<br>当我们能够计算$T$，它的雅可比行列式，evaluate 目标分布$p^</em>$以及从$$p(u)$$中sample时，使用反向KL divergence是合适的，事实上，即使我们只能evaluate 目标分布乘以某个正则化常数，也可以最小化上式, $p^*_{\mathrm x}(\mathrm x) = \tilde p_{\mathrm x}(\mathrm x)/C$，其中，$\tilde p_{\mathrm x}(\mathrm x)$是一个更好处理的分布，因此，可以得到<br>$$<br>\mathcal{L}(\boldsymbol{\theta})=\mathbb{E}<em>{p</em>{u}(\mathbf{u} ; \psi)}\left[\log p_{\mathrm{u}}(\mathbf{u} ; \boldsymbol{\psi})-\log \left|\operatorname{det} J_{T}(\mathbf{u} ; \boldsymbol{\phi})\right|-\log \tilde{p}<em>{\mathrm{x}}(T(\mathbf{u} ; \boldsymbol{\phi}))\right]+\text { const. }<br>$$<br>当我们有N条来自于$p</em>{u}(\mathbf{u} ; \psi)$的samples，为了最小化上式，使用蒙特卡罗法，并对变换$T$的参数$\phi$求偏导，可得<br>$$<br>\nabla_{\phi} \mathcal{L}(\boldsymbol{\theta}) \approx-\frac{1}{N} \sum_{n=1}^{N} \nabla_{\phi} \log \left|\operatorname{det} J_{T}\left(\mathbf{u}<em>{n} ; \boldsymbol{\phi}\right)\right|+\nabla</em>{\phi} \log \tilde{p}<em>{\mathbf{x}}\left(T\left(\mathbf{u}</em>{n} ; \boldsymbol{\phi}\right)\right)<br>$$<br>由于$u_n\sim p_u(u)$，且$\phi$不更新因为$u_n$的采样$\phi$是固定的，具体优化如下：<br>$$<br>\nabla_{\phi} \mathcal{L}(\boldsymbol{\theta}) \approx-\frac{1}{N} \sum_{n=1}^{N} \nabla_{\phi} \log \left|\operatorname{det} J_{T}(\mathbf{u}_n ; \boldsymbol{\phi})\right|+\nabla \boldsymbol{\phi} \log \tilde{p}_\mathbf{x}(T(\mathbf{u}_n ; \boldsymbol{\phi}))<br>$$<br>反向KL散度，是通过对$p(u)$采样通过变量替换以避开$x$来训练评估我们的模型。其常见的应用有变分推断和模型蒸馏。变分推断指的是，先验概率或似然函数$p(x)$ is intractable ，变分推断想求后验 $p(z|x)$，只能通过构造新的分布去逼近。那么分布是已知的，对隐变量的采样是未知的，符合我们的条件。在模型蒸馏中， $p^*$ 符合同样可求，但采样不方便的境地。因此采用反向KL散度评估模型去训练蒸馏，使新的模型具有快速采样的能力。</p>
</li>
</ol>
<blockquote>
<p>如何找到映射函数T<strong>既是可逆的而且逆变换计算容易</strong>，这个$T$又可以<strong>简便计算雅克比行列式</strong>？对于逆变换计算这一点，如果无法高效进行逆计算，那么评估训练模型以及采样都是困难的，取决于$f_{\phi_k}$实现的是$T_k$还是$T_k^{-1}$，因此逆变换的高效计算是个因模型而异的难题。</p>
<p>basic trick: 计算雅可比行列式<strong>最好优化成三角矩阵 diagonal matrix</strong>，because the determinant of a triangular matrix is just the product of the diagonal elements, 因此将原先的$O(D^3)$复杂度降为$O(D)$，能够解决部分计算问题！</p>
</blockquote>
<h2 id="与VAE和GAN的比较"><a href="#与VAE和GAN的比较" class="headerlink" title="与VAE和GAN的比较"></a>与VAE和GAN的比较</h2><p>normalizing flow：</p>
<ul>
<li>exact log-likelihood evaluation: $\log p_\theta(x) = \log p_\theta(z) + \sum_{i=1}^K \log \left|\operatorname{det}\left( \frac{\part f_i*{-1}}{\part z_i} \right)\right|$</li>
<li>exact posterior inference : $z=f^{-1}(x)$</li>
</ul>
<p>VAE:</p>
<ul>
<li>Lower bound on log-likelihood (ELBO)</li>
<li>approximate posterior $q_\phi(z|x)$ (encoder network) [because the actural posterior is intractable]</li>
</ul>
<p>GAN:</p>
<ul>
<li>No log-likelihood evaluation (optimize a minx objective involving the discriminator and generator)</li>
<li>no latent variable inference (generator cannot ensure full support over data)</li>
</ul>
<h2 id="模型1-Finite-compositions"><a href="#模型1-Finite-compositions" class="headerlink" title="模型1-Finite compositions"></a>模型1-Finite compositions</h2><p>Finite compositions model的优点在于，增加简单变换$T$的个数为$K$，仅仅增加$O(K)$的计算复杂度。</p>
<p>Finite compositions model: construct a flow with transformation $T$ by composing a finite number of simple transformations $T_k$. 有限个简单变换$T$构成的flow mode</p>
<ol>
<li>Autgressive flows</li>
<li>Linear flows</li>
<li>Residual flows</li>
</ol>
<h3 id="耦合技术-Coupling-layers"><a href="#耦合技术-Coupling-layers" class="headerlink" title="耦合技术 Coupling layers"></a>耦合技术 Coupling layers</h3><p>NICE (Dihn et al. 2015), Real NVP (Dihn et al. 2017), Glow (Kingma and Dhariwal, 2018), WaveGlow (Prenger et al. 2019), FloWaveNet (kim et al. 2019), Flow++ (Ho et al. 2019).</p>
<p>优点：</p>
<ul>
<li>采用了计算对称性，模型评估和求逆计算的速度快（efficiently）</li>
<li>模型评估和采样可以在一次神经网络传递中进行（allow both density evaluation and sampling to be performed in a single neural network pass）</li>
</ul>
<p>缺点：</p>
<ul>
<li>流模型的表达力可能不足。因此需要考虑计算和表达力的动态平衡。</li>
</ul>
<h3 id="自回归技术"><a href="#自回归技术" class="headerlink" title="自回归技术"></a>自回归技术</h3><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>概率建模</p>
<p>样本生成</p>
<p>模型推断</p>
<p>表示学习（构建产生式模型和预测模型的混合模型，如监督学习和强化学习）</p>
<p>概率模型的建模，推断，监督学习和强化学习这些领域。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhang-xiaoxue.github.io/2020/06/30/Reinforcement%20Learning/%E7%A8%80%E7%96%8F%E5%A5%96%E5%8A%B1%E4%B8%8B%E7%9A%84%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/photo_blue.jpg">
      <meta itemprop="name" content="Xiaoxue Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiaoxue Zhang - NUS">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/30/Reinforcement%20Learning/%E7%A8%80%E7%96%8F%E5%A5%96%E5%8A%B1%E4%B8%8B%E7%9A%84%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">稀疏奖励下的强化学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-06-30 12:00:00" itemprop="dateCreated datePublished" datetime="2020-06-30T12:00:00+08:00">2020-06-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-08-16 15:23:03" itemprop="dateModified" datetime="2021-08-16T15:23:03+08:00">2021-08-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Reinforcement-Learning/" itemprop="url" rel="index"><span itemprop="name">Reinforcement Learning</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="稀疏奖励下的强化学习"><a href="#稀疏奖励下的强化学习" class="headerlink" title="稀疏奖励下的强化学习"></a>稀疏奖励下的强化学习</h1><p>当agent无法得到足够多的有效reward或者说得到的是稀疏奖励（sparse reward），会导致agent学习缓慢，甚至无法 有效学习。</p>
<p>解决方法：</p>
<h2 id="1-Use-data-to-improve-learning"><a href="#1-Use-data-to-improve-learning" class="headerlink" title="1. Use data to improve learning"></a>1. Use data to improve learning</h2><h3 id="1-1-Curiosity-driven"><a href="#1-1-Curiosity-driven" class="headerlink" title="1.1 Curiosity driven"></a>1.1 Curiosity driven</h3><blockquote>
<p>paper: Episodic Curiosity through Reachability</p>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1810.02274.pdf">https://arxiv.org/pdf/1810.02274.pdf</a></p>
</blockquote>
<p>该方法改变了 agent「好奇心」的生成方式和奖励机制，将 agent 对环境信息观察的记忆信息引入奖励机制中，有效降低了 agent「原地兜圈」、「拖延」等不良行为，提升了强化学习模型的性能。</p>
<p>本文引入「好奇心（Curiosity）」的基本思路是：只对那些需要花费一定努力才能达到的结果给予奖励（这部分结果一定是在已经探索过的环境部分之外）。根据探索环境所需要的步骤数量来衡量这些努力。为了估计步骤数量，本文训练了一个神经网络近似器：给定两个观测值，预测将它们分开需要执行多少步。图 1 给出了通过可达性（Reachability）来说明行动的新颖性（Novelty）的概念。图中的节点是观测值，边是可能的转换。蓝色的节点已经在记忆内存中，绿色的节点可以在 k=2 步内从记忆内存中到达（不新颖），橙色的节点距离较远—需要超过 k 步才能到达（新颖）。</p>
<h3 id="1-2-Reward-shaping"><a href="#1-2-Reward-shaping" class="headerlink" title="1.2 Reward shaping"></a>1.2 Reward shaping</h3><h3 id="1-3-Imitation-learning"><a href="#1-3-Imitation-learning" class="headerlink" title="1.3 Imitation learning"></a>1.3 Imitation learning</h3><h3 id="1-4-Curriculum-learning"><a href="#1-4-Curriculum-learning" class="headerlink" title="1.4 Curriculum learning"></a>1.4 Curriculum learning</h3><h2 id="2-Improve-model"><a href="#2-Improve-model" class="headerlink" title="2. Improve model"></a>2. Improve model</h2><h3 id="2-1-Hierarchical-reinforcement-learning"><a href="#2-1-Hierarchical-reinforcement-learning" class="headerlink" title="2.1 Hierarchical reinforcement learning"></a>2.1 Hierarchical reinforcement learning</h3><h3 id="2-2-Meta-learning"><a href="#2-2-Meta-learning" class="headerlink" title="2.2 Meta-learning"></a>2.2 Meta-learning</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhang-xiaoxue.github.io/2020/06/30/Chance%20Constraints/Chance%20Constrained%20Problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/photo_blue.jpg">
      <meta itemprop="name" content="Xiaoxue Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiaoxue Zhang - NUS">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/30/Chance%20Constraints/Chance%20Constrained%20Problem/" class="post-title-link" itemprop="url">Chance Constrained Problem</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-06-30 12:00:00" itemprop="dateCreated datePublished" datetime="2020-06-30T12:00:00+08:00">2020-06-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-13 15:32:02" itemprop="dateModified" datetime="2021-05-13T15:32:02+08:00">2021-05-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Chance-Constraints/" itemprop="url" rel="index"><span itemprop="name">Chance Constraints</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>A formulation of an optimization problem.</p>
<ul>
<li>Ensure the probability of meeting constraints is above a certain level.</li>
<li>AKA. Restrict the feasible region so that the confidence level of solution is high.</li>
</ul>
<p>$$<br>\begin{aligned}<br>\min &amp;\  f(x, \xi) \<br>\text{s.t. } &amp;\  g(x,\xi) = 0\<br>&amp; \ h(x,\xi) \geq 0<br>\end{aligned}<br>$$</p>
<p>where $x$ is decision variables, $\xi$ is the vector of uncertainty.</p>
<h2 id="Deterministic-Reformulations"><a href="#Deterministic-Reformulations" class="headerlink" title="Deterministic Reformulations:"></a>Deterministic Reformulations:</h2><ul>
<li><p>expectation constraints:<br>$$<br>h(x,\xi) \geq 0 \ \rightarrow \ h(x,\mathbb{E} \xi) \ge 0<br>$$<br>easy to solve, solutions at low costs; But, solutions not robust</p>
</li>
<li><p>Worst-case constraints:<br>$$<br>h(x,\xi) \geq 0 \ \rightarrow \ h(x, \xi) \ge 0 \ \  \forall \xi<br>$$<br>absolutely robust solution; But, solutions expensive or not exit</p>
</li>
<li><p>Chance Constraints:<br>$$<br>h(x,\xi)\ge 0 \rightarrow \ \ \underbrace{P(h(x,\xi)\ge 0)}_{\phi(x)} \ge p, \  p\in[0,1]<br>$$<br>robust solutions, not too expensive; But, difficult to solve</p>
</li>
</ul>
<h2 id="Chance-constraints"><a href="#Chance-constraints" class="headerlink" title="Chance constraints"></a>Chance constraints</h2><p>Inequality constraints: $P(h(x, \xi) \geq 0) \geq p$ </p>
<blockquote>
<p>in some practice, output variables $y$ (belongs to $x$) should be $y_\min \leq y(\xi) \leq y_\max$. Then, $P(y_\min \leq y(\xi) \leq y_\max) \geq p$</p>
</blockquote>
<p>Random Right-hand Side: Use distribution function $F_\xi (h(\xi \ge p))$</p>
<h3 id="Single-vs-Joint-Chance-Constraint"><a href="#Single-vs-Joint-Chance-Constraint" class="headerlink" title="Single vs. Joint Chance Constraint"></a>Single vs. Joint Chance Constraint</h3><p>since both $h(x,\xi)$ and $y(\xi)$ are vectors,</p>
<ul>
<li><p>individual chance constraint:<br>$$<br>h_i(x,\xi) \geq 0 \rightarrow P(h_i(x,\xi) \geq 0)\geq p \quad (i=1,\cdots, m)<br>$$<br>Random right-hand side: $h_i(x,\xi) = f_i(x)-\xi_i  $</p>
<p>$P(f_i(x)\ge \xi_i) = P(h_i(x-\xi)\ge 0)\ge p, (i=1,\cdots,m) \iff f_i(x)\ge \underbrace{q_i(p)}_{p-\text{quantile of } \xi_i} \ (i=1, \cdots, m)$</p>
<p>Individual chance constraints are easy to solve, however, they only guarantee that each line satisfies the constraint to a certain confidence level.</p>
</li>
<li><p>Joint chance constraint:<br>$$<br>h_i(x,\xi) \geq 0 \rightarrow P(h_i(x,\xi) \geq 0 \ (i=1,\cdots, m))\geq p \quad<br>$$<br> Joint chance constraint ensures that the constraint as a whole is satisfied to a certain confidence level, however, it is incredibly difficult to solve, even numerically.</p>
</li>
</ul>
<h3 id="Solving-Method"><a href="#Solving-Method" class="headerlink" title="Solving Method:"></a>Solving Method:</h3><ul>
<li><p>Simple case (decision and random variables can be decoupled):</p>
<p>chance constraints can be relaxed into deterministic constraints using probability density functions (pdf). Then, use LP or NLP to solve.</p>
<ul>
<li><p>Linear <u>( $h$ is leaner in $\xi$ )</u>, i.e., $P(h(x)\ge 0)\ge p$</p>
</li>
<li><p>Two types:</p>
<ul>
<li>separable model: $P(y(x)\ge A\xi)\ge p$</li>
<li>bilinear model: $P(\Xi \cdot x \geq b) \geq p$</li>
</ul>
</li>
<li><p>calculate the probability by using the probability density function (pdf) and substitute the left hand side of the constraint with a deterministic expression</p>
<ul>
<li>PDF :<ul>
<li>statistical regression (abundant data), </li>
<li>interpolation and extrapolation (few data)</li>
<li>Marginal distribution function (when uncertain variables has correlations)</li>
</ul>
</li>
<li>Feasible region depends on confidence level<ul>
<li>high confidence level $\rightarrow$ small feasible region</li>
<li>low confidence level $\rightarrow$ larger feasible region</li>
<li>can make different confidence level with important</li>
</ul>
</li>
</ul>
</li>
<li><p>Nonlinear</p>
<p>relax problem by transforming into deterministic NLP problem.</p>
<ul>
<li>Solving nonlinear chance constrained problem is difficult, because nonlinear propogation makes it hard to obtain the distribution if output variables when distribution of uncertainty is unknown.<ul>
<li>strategy: back-mapping </li>
<li>robust optimization</li>
<li>sample average approximation</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Complex case (decision and random variables interact and cannot decouple)</p>
<ul>
<li>impossible to solve.</li>
</ul>
</li>
</ul>
<h2 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges:"></a>Challenges:</h2><h3 id="Structural-Challenges"><a href="#Structural-Challenges" class="headerlink" title="Structural Challenges"></a>Structural Challenges</h3><h4 id="Structural-Property"><a href="#Structural-Property" class="headerlink" title="Structural Property:"></a>Structural Property:</h4><ul>
<li><p>Probability function: $\varphi(x) :=P(h(x, \xi) \geq 0)$</p>
</li>
<li><p>set of feasible decisions: $M :=\left{x \in \mathbb{R}^{n} | \varphi(x) \geq p\right}$</p>
<p>Proposition ====(Upper Semicontinuity, closeness)<br>if $h_i$ are usc, then so is $\varphi$. Then, $M$ is closed</p>
<img src="https://raw.githubusercontent.com/Lisnol1/PicGo--/master/20190827220601.png" style="zoom:40%">

<p>==Proposition==<br>if $h_i$ are continuous, and $P(h_i(x,\xi)=0)=0, \forall x \in R^n \forall i \in {1,\cdots,s}$, then $\phi$ is continuous too.</p>
<p>==Proposition==<br>if $\xi$ has pdf $f_\xi$, i.e., $F_\xi(z)=\int_{-\inf}^{z} f_\xi(x) dx$, then $F_\xi$ is continuous.</p>
</li>
</ul>
<p>==Theorem== (Wang 1985, Romisch/Schultz 1993)<br>  If $\xi$ has a density $f_\xi$, then $F_\xi$ is Lipschitz continuous if and only if all marginal densities $f_{\xi_i}$ are essentially bounded.</p>
<p>  ==Theorem (R.H./R¨omisch 2010)==<br>  If $\xi$ has a density $f_\xi$ such that $f^{−1/s}_\xi$ is convex, then $F_\xi$ is Lipschitz continuous</p>
<p>  Assumption satisfied by most prominent multivariate distributions:<br>  Gaussian, Dirichlet, t, Wishart, Gamma, lognormal, uniform</p>
<h3 id="Numerical-Challenges"><a href="#Numerical-Challenges" class="headerlink" title="Numerical Challenges:"></a>Numerical Challenges:</h3><p>$$<br>P(y(x)\ge \xi)\ge p = P(h(\xi \leq x)\ge p) = F_\xi (h(x) \ge p)<br>$$</p>
<p>If $\xi \sim \mathcal{N}(\mu, \Sigma)$ with $\Sigma$ positive definite (regular Gaussian),<br>$$<br>\frac{\partial F_{\xi}}{\partial z_{i}}(z)=f_{\xi_{i}}\left(z_{i}\right) \cdot F_{\tilde{\xi}\left(z_{i}\right)}\left(z_{1}, \ldots, z_{i-1}, z_{i+1} \ldots, z_{s}\right) \quad(i=1, \ldots, s)<br>$$<br>Efficient method to compute $F_\xi$ (and $\nabla F_{\xi}$) :</p>
<ul>
<li><p>code by A. Genz. computes Gaussian probabilities of rectangles:</p>
<p>$\mathbb{P}(\xi \in[a, b]) \quad\left(F_{\xi}(z)=\mathbb{P}(\xi \in(-\infty, z])\right.$</p>
<p>allows to consider problems with up to a few hundred random variables.</p>
</li>
<li><p>cope with more complicated models, like $\mathbb{P}(h(x) \geq A \xi) \geq p, \quad \mathbb{P}(\Xi \cdot x \geq b) \geq p$:</p>
</li>
</ul>
<p>Compute Derivatives for Gaussian Probabilities of Rectangles</p>
<p>Let $\xi \sim \mathcal{N}(\mu, \Sigma)$ with $\Sigma$ positive definite.  Consider a two-sided probabilistic constraint: $\mathbb{P}(\xi \in[a(x), b(x)]) \geq p$. Then,     $\alpha_{\xi}(a(x), b(x)) \geq p, \quad$ where $\quad \alpha_{\xi}(a, b) :=\mathbb{P}(\xi \in[a, b])$</p>
<h4 id="Partial-derivatives"><a href="#Partial-derivatives" class="headerlink" title="Partial derivatives:"></a>Partial derivatives:</h4><ul>
<li><p>Method 1:</p>
<p>Reduction to distribution functions, then use known gradient formula.<br>$$<br>\alpha_{\xi}(a, b)=\sum\limits_{i_{1}, \ldots, i_{s} \in{0,1}}(-1)^{\left[s+\sum_{j=1}^{s} i_{j}\right]} F_{\xi}\left(y_{i_{1}}, \ldots, y_{i_{s}}\right), \quad y_{i_{j}} :=\left{<br>\begin{array}{ll}<br>{a_{j}} &amp; {\text { if } i_{j}=0} \<br>{b_{j}} &amp; {\text { if } i_{j}=1}<br>\end{array}<br>\right.<br>$$<br>For dimension $s$, there are $2^s$ terms in the sum. Not practicable!</p>
</li>
<li><p>Method 2:<br>$$<br>\alpha_{\xi}(a, b)=\mathbb{P}\left(\left(\begin{array}{c}{\xi} \ {-\xi}\end{array}\right) \leq\left(\begin{array}{c}{b} \ {-a}\end{array}\right)\right), \quad\left(\begin{array}{c}{\xi} \ {-\xi}\end{array}\right) \sim \mathcal{N}\left(\left(\begin{array}{c}{\mu} \ {-\mu}\end{array}\right),\left(\begin{array}{cc}{\Sigma} &amp; {-\Sigma} \ {-\Sigma} &amp; {\Sigma}\end{array}\right)\right)<br>$$<br>$\Longrightarrow$ Singular normal distribution, gradient formula not available</p>
<p>==<strong>Proposition (Ackooij/R.H./M¨ oller/Zorgati 2010)</strong>==<br>Let $\xi \sim \mathcal{N}(\mu, \Sigma)$ with $\Sigma$ positive definite and $f_\xi$ the corresponding density. Then, $\frac{\partial \alpha_{\xi}}{\partial b_{i}}(a, b)=f_{\xi_{i}}\left(b_{i}\right) \alpha_{\tilde{\xi}}\left(b_{i}\right)(\tilde{a}, \tilde{b}) ; \quad \frac{\partial \alpha_{\xi}}{\partial a_{i}}(a, b)=-f_{\xi_{i}}\left(a_{i}\right) \alpha_{\tilde{\xi}}\left(a_{i}\right)(\tilde{a}, \tilde{b})$ with the tilda-quantities defined as in the gradient formula for Gaussian distribution functions.</p>
<p>$\Longrightarrow$ Use Genz’ code to calculate $\alpha_\xi$ and $\nabla_{a, b} \alpha_{\xi}$ at a time.</p>
</li>
</ul>
<h4 id="Derivatives-for-separated-model-with-Gaussian-data"><a href="#Derivatives-for-separated-model-with-Gaussian-data" class="headerlink" title="Derivatives for separated model with Gaussian data:"></a>Derivatives for separated model with Gaussian data:</h4><p>Let $\xi \sim \mathcal{N}(\mu, \Sigma)$ with $\Sigma$ positive definite and consider the probability function:<br>$$<br>\beta_{\xi, A}(x) :=\mathbb{P}(A \xi \leq x)<br>$$<br>If the rows of $A$ are linearly independent, then put $\eta :=A \xi \sim \mathcal{N}\left(A \mu, A \Sigma A^{T}\right)$, then<br>$$<br>\Longrightarrow \quad \beta_{\xi, A}(x)=F_{\eta}(x)\quad   \text{regular Gaussian distribution function}<br>$$<br>otherwise, $F_\eta$ is a singular Gaussian distribution function (gradient formula not available)</p>
<p>==<strong>Theorem (R.H./M¨ oller 2010, see talk by A. M¨ oller, Thursday, 3.20 p.m., R. 1020)</strong>==<br>$\frac{\partial \beta_{\xi, A}}{\partial x_{i}}(x)=f_{A_{i} \xi}\left(x_{i}\right) \beta_{\tilde{\xi}, \tilde{A}}(\tilde{x})$ where $\tilde{\xi} \sim \mathcal{N}\left(0, l_{s-1}\right)$ and $\tilde{A}$, $\tilde{x}$ can be calculated explicitly from $A$ and $x$.</p>
<p>use e.g., Deak’s code for calculating normal probabilities of convex sets.</p>
<h4 id="Derivatives-for-bilinear-model-with-Gaussian-data"><a href="#Derivatives-for-bilinear-model-with-Gaussian-data" class="headerlink" title="Derivatives for bilinear model with Gaussian data"></a>Derivatives for bilinear model with Gaussian data</h4><p>probability function: $\gamma(x) :=\mathbb{P}(\Xi x \leq a)$ with normally distributed $(m,s)$ coefficient matrix. Let $\xi_i$ be the $i$th row of $\Xi$\</p>
<p>$$<br>\begin{array}{rCl}<br>\gamma(x) &amp;=F_{\eta}(a) \ \nabla \gamma(x) &amp;=\sum_{i=1}^{m} \frac{\partial F_{\eta}}{\partial z_{i}}(\beta(x)) \nabla \beta_{i}(x)+\sum_{i, j=1}^{m} \frac{\partial^{2} F_{\eta}}{\partial z_{i} \partial z_{j}}(\beta(x)) \nabla R_{i j}(x)<br>\end{array}<br>$$</p>
<p>$$<br>\begin{aligned} \eta &amp; \sim \mathcal{N}(0, R(x)) \ \mu(x) &amp;=\left(\mathbb{E} \xi_{i}^{T} x\right)<em>{i=1}^{m} \ \Sigma(x) &amp;=\left(x^{T} \operatorname{Cov}\left(\xi</em>{i}, \xi_{j}\right) x\right)<em>{i, j=1}^{m} \ D(x) &amp;=\operatorname{diag}\left(\Sigma</em>{i i}^{-1 / 2}(x)\right)_{i=1}^{m} \ R(x) &amp;=D(x) \Sigma(x) D(x) \ \beta(x) &amp;=D(x)(a-\mu(x)) \end{aligned}<br>$$</p>
<p><img src="https://raw.githubusercontent.com/Lisnol1/PicGo--/master/20190828190059.png" style="zoom:35%"> <img src="https://raw.githubusercontent.com/Lisnol1/PicGo--/master/20190828190347.png" style="zoom: 35%">  </p>
<p><img src="https://raw.githubusercontent.com/Lisnol1/PicGo--/master/20190828190706.png" style="zoom:38%"> <img src="https://raw.githubusercontent.com/Lisnol1/PicGo--/master/20190828190545.png" style="zoom: 36%"></p>
<blockquote>
<p>e.g. hold constraints and gradients constant while calculating probabilities. [No closed-form analytical representation of probabilities]</p>
</blockquote>
<h3 id="Convexity-Challenges"><a href="#Convexity-Challenges" class="headerlink" title="Convexity Challenges"></a>Convexity Challenges</h3><p>$$<br>P(y(x)\ge \xi)\ge p = P(h(\xi \leq x)\ge p) = F_\xi (h(x) \ge p)<br>$$</p>
<ul>
<li><p>Global optimization: if the optimization problem is convex, the local optimum is global optimum; otherwise, methods such as McCormick Envelope Approximation should be used.</p>
<p>if $F_\xi (h(x) \ge p)$ is concave, the optimization problem is convex.</p>
<p><u>Sufficient:</u></p>
<ol>
<li>components $h_j$ concave: e.g., $h$ is a linear mapping</li>
<li>$F_\xi $ increasing: automatic (distribution function)</li>
<li>$F_\xi$ concave: Never, because pdf bounded by 0 and 1.</li>
</ol>
<p>If <u>exist a strictly increasing function</u> $\varphi: \mathbb{R}<em>{+} \rightarrow \mathbb{R} $ such that $\varphi \circ F</em>{\xi}$ is concave:</p>
<p>​    i.e., $F_\xi (h(x) \ge p) \iff \varphi(F_\xi (h(x)) \ge \varphi(p)$. </p>
<p>​    then,  $\underbrace{\varphi \circ F_{\xi}}_{\text {increasing } \atop \text { concave }} \circ h$ is concave if the components $h_i$ are concave</p>
<ul>
<li><p>potential candidates: $\varphi = \log$, $\varphi=-(\cdot)^{-n}$</p>
<img src="C:\Users\adminnus\AppData\Roaming\Typora\typora-user-images\1566959194981.png" style="zoom: 80%"></li>
</ul>
<p>==<strong>Theorem (Pr´ekopa 1973 )</strong>==<br>Log-concavity of the density implies log-concavity of the distribution function.</p>
<p><u>example log-concave distribution</u>: Normal, Gaussian, Dirichlet, Student, lognormal, Gamma, uniform, Wishart</p>
<p><strong>Separable model:</strong></p>
<p>==<strong>Corollary (Convexity in the separable model)</strong>==<br>Consider the feasible set $M := {x \in \mathbb{R}^n | P(A\xi \leq h(x)) \geq p}$. Let $\xi$ have a density $f_\xi$ such that $\log f_\xi$ is concave and let the $h_i$ be concave (e.g., $h$ linear). Then, $M$ is convex for any $p\in[0, 1]$.</p>
<p><strong>Bilinear model:</strong></p>
<p>feasible set $M :=\left{x \in \mathbb{R}^{n} | \mathbb{P}(\Xi x \leq a) \geq p\right}$</p>
</li>
</ul>
<p>==<strong>Theorem (Van de Panne/Popp, Kataoka 1963, Kan 2002, Lagoa/Sznaier 2005)</strong>==<br>  Let $\Xi$  have one row only which has an elliptically symmetric or log-concave symmetric distribution (e.g., Gaussian). Then, $M$ is convex for $p\ge 0.5$.</p>
<p>  ==<strong>Theorem (R.H./Strugarek 2008)</strong>==<br>Let the rows $\xi_i$ of $\Xi$ be Gaussian according to $\xi_i \sim \mathcal{N}(\mu_i,\Sigma_i)$. If the $\xi_i$ are pairwise independent, then $M$ is convex for $p &gt; \Phi(\max{\sqrt{3},\tao}), where</p>
<ul>
<li>$\Phi =$ 1-dimensional standard normal distribution function</li>
<li>$\tau=\max <em>{i} \lambda</em>{\max }^{(i)}\left[\lambda_{\min }^{(i)}\right]^{-3 / 2}\left|\mu_{i}\right|$<br>-$\lambda_{\max }^{(i)}, \lambda_{\min }^{(i)} :=$ largest and smallest eigenvalue of $\Sigma_i$.<br>Moreover, $M$ is compact for $p&gt;\min <em>{i} \Phi\left(\left|\mu</em>{i}\right|<em>{\Sigma</em>{i}^{-1}}\right)$</li>
</ul>
<blockquote>
<p>A challenging issue comes in when the distribution is uniform or normal with independent components, since these may lack strong log concavity in certain circumstances. Furthermore, it should be noted that the Student’s t-distribution, the Cauchy distribution, the Pareto distribution, and the log-normal distribution are not log concave.</p>
</blockquote>
<h3 id="Stability-Challenges"><a href="#Stability-Challenges" class="headerlink" title="Stability Challenges"></a>Stability Challenges</h3><p>Distribution of $\xi$ rarely known $\Longrightarrow$ Approximation by some $\eta$ $\Longrightarrow$ Stability?</p>
<p>==<strong>Theorem (R.H./W.R¨omisch 2004)</strong>==</p>
<ul>
<li>$f$ convex, $C$ convex, closed, $\xi$ has log-concave density</li>
<li>\Psi(\xi)$ nonempty and bounded</li>
<li>$\exists x \in C : \quad \mathbb{P}(\xi \leq A x)&gt;p$ (Slater point)<br>Then, $\Psi$ is upper semicontinuous at $\xi$:<br>$$<br>\Psi(\eta) \subseteq \Psi(\xi)+\varepsilon \mathbb{B} \quad \text { for } \quad \sup <em>{z \in \mathbb{R}^{s}}\left|F</em>{\xi}(z)-F_{\eta}(z)\right|&lt;\delta<br>$$<br>If in addition</li>
<li>$f$ convex-quadratic, $C$ polyhedron,</li>
<li>$\xi$ has strongly log-concave distribution function,<br>then $\Psi$ is locally Hausdorff-Holder continuous at $\xi$:</li>
</ul>
<p>$$<br>\left.d_{\text {Haus }}(\psi(\eta), \psi(\xi)) \leq L \sqrt{\sup <em>{z \in \mathbb{R}^{s}}\left|F</em>{\xi}(z)-F_{\eta}(z)\right|} \quad \text { (locally around } \xi\right)<br>$$</p>
<p>pdf is nor precise, most is approximation. </p>
<ul>
<li>slight changes in distribution may cause major changes to optimum</li>
<li>if assumed distribution is slightly different from actual distribution, not stable.</li>
<li> In order to achieve Hölder- or Lipschitz stability one has to impose further structural conditions, such as strong log-concavity, strict complementarity, and C1,1-differentiability.</li>
</ul>
<h2 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h2><h3 id="Engineering"><a href="#Engineering" class="headerlink" title="Engineering:"></a>Engineering:</h3><p>UGV, UAV: Optimal Navigation and Reliable Obstacles Avoidance</p>
<p>System description:<br>$$<br>\begin{aligned}<br>\dot x &amp; = f(x,u,\xi)\<br>0 &amp; = g(x,u,\xi)<br>\end{aligned}<br>$$<br>$\xi$ may be:</p>
<ul>
<li>random obstacles</li>
<li>sensor measurement errors</li>
<li>state generated errors</li>
</ul>
<p>Probability density function of these variables are estimated based on previous data. and formulated into chance constraints.</p>
<p> Based on these constraints, unmanned vehicles can travel through a specific region with the shortest distance while avoiding random obstacles at a high confidence level.2</p>
<h3 id="Power-system-management"><a href="#Power-system-management" class="headerlink" title="Power system management:"></a>Power system management:</h3><h3 id="Risk-management"><a href="#Risk-management" class="headerlink" title="Risk management"></a>Risk management</h3><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>The chance-constraint method is a great way to solve optimization problems due to its robustness. It allows one to set a desired confidence level and take into account trade-off between two or more objectives. However, it can be extremely difficult to solve. Probability density functions are often difficult to formulate, especially for the nonlinear problems. Issues with convexity and stability of these questions mean that small deviations from the actual density function could cause major changes in the optimal solution. Further complications are added when the variables with and without uncertainty can not be decoupled. Due to these complications, there’s no single approach to solving chance-constraint problems. <u>Though the most common approach to simple questions is to transform the chance constraints into deterministic functions by decoupling the variables with and without uncertainty and using probability density functions.</u></p>
<p>This approach has many applications in the engineering field and the finance field. Namely, it is widely used in energy management, risk management, and more recently, determination of production level, performance of industrial robots, and performance of unmanned vehicle. A lot of research in the area focuses on solving nonlinear dynamic questions with chance constraints.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhang-xiaoxue.github.io/2020/06/30/Machine%20Learning/Uncertainty_Modelling_in_AI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/photo_blue.jpg">
      <meta itemprop="name" content="Xiaoxue Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiaoxue Zhang - NUS">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/30/Machine%20Learning/Uncertainty_Modelling_in_AI/" class="post-title-link" itemprop="url">Uncertainty Modelling in AI</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-06-30 12:00:00" itemprop="dateCreated datePublished" datetime="2020-06-30T12:00:00+08:00">2020-06-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-08-16 15:12:14" itemprop="dateModified" datetime="2021-08-16T15:12:14+08:00">2021-08-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Machine-Learning/" itemprop="url" rel="index"><span itemprop="name">Machine Learning</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Uncertainty-Modelling-in-AI"><a href="#Uncertainty-Modelling-in-AI" class="headerlink" title="Uncertainty Modelling in AI"></a>Uncertainty Modelling in AI</h1><p>All materials are from Module CS5340 (NUS Computing)</p>
<p>PGM (Probabilistic Graphical Modeling)</p>
<ul>
<li>gain global insight based on local observations</li>
</ul>
<p><strong>Key Ideas:</strong> </p>
<ul>
<li><p><strong>Represent</strong> the world as a collection of random variables $X_1, \cdots, X_N$ with joint distribution $p(X_1, \cdots, X_N)$</p>
</li>
<li><p><strong>Learn</strong> the distribution from data. </p>
</li>
<li><p>Perform “<strong>inference</strong>” (compute conditional distributions ($p(X_i|X_1=x_1,\cdots,X_N=x_N)$).</p>
</li>
</ul>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="Probability-space"><a href="#Probability-space" class="headerlink" title="Probability space"></a>Probability space</h2><p>Three parts:</p>
<ul>
<li>Outcome space $\Omega$: space of possible outcomes </li>
<li>Event space $E$: $E\subseteq 2^{\Omega}$, subset of power set of $\Omega$<ul>
<li>contains <u>empty</u> $\emptyset$ and <u>trivial event</u> $\Omega$</li>
<li><u>closed under union.</u> if $\alpha, \beta \in E$, so is $\alpha \cup\beta$</li>
<li><u>closed under complement</u>. if $\alpha \in E$, So is $\Omega -\alpha$</li>
</ul>
</li>
<li><strong>Probability distribution $P$:</strong> mapping from events in $E$ into real values<ul>
<li>Non negativity</li>
<li>sum to 1</li>
<li>Mutually disjoint events: if $\alpha, \beta \in E$, and $\alpha \cap \beta=\emptyset$, then $P(\alpha\cup\beta)=P(\alpha)\cup P(\beta)$.</li>
</ul>
</li>
</ul>
<p>Probability distribution:</p>
<ul>
<li><p>$X$: random variables. $x$: generic values [$x\in Val(X)$].</p>
</li>
<li><p>Indicator Random Variables: map every outcome to 0 or 1.: Just indication</p>
</li>
<li><p>Discrete vs.. continuous</p>
<ul>
<li>Discrete:<ul>
<li>PMF (Probability mass function): $p(x)$</li>
</ul>
</li>
<li>Continuous:<ul>
<li>PDF (Probability Density function) : $p(x):R\rightarrow R_{\geq 0}$</li>
<li>$P(X)$ is a cumulative function</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Probability:</p>
<ul>
<li>Joint probability:</li>
</ul>
<h3 id="Basic-operations"><a href="#Basic-operations" class="headerlink" title="Basic operations"></a>Basic operations</h3><h4 id="Marginalization"><a href="#Marginalization" class="headerlink" title="Marginalization"></a>Marginalization</h4><p>Recover probability distribution of any variable <u>in a joint distribution</u> by <u>integrating (or summing)</u> over all other variables.</p>
<p>$${} p(x)=\int p(x,y) dy ;\quad p(y)=\int(x,y) dx$$</p>
<p>$p(x)=\sum\limits_y p(x,y) ;\quad p(y)=\sum\limits_x(x,y) $</p>
<h4 id="Conditional-probability"><a href="#Conditional-probability" class="headerlink" title="Conditional probability"></a>Conditional probability</h4><p>$p(x|Y=y^*)$</p>
<p>can be extracted from joint probability.</p>
<p>$P(x|Y=y^*)=\frac{p(x,Y=y^*)}{\int\limits_x p(x,Y=y^*) dx} = \frac{p(x,Y=y^*)}{p(Y=y^*)}$</p>
<p>i.e. $p(x|y)=\frac{p(x,y)}{p(y)}$</p>
<p>So, $p(x,y)=p(x|y)p(y)=p(y|x)p(x)$   : <em>chain rule of product rule</em></p>
<h4 id="Bayes-rule"><a href="#Bayes-rule" class="headerlink" title="Bayes rule"></a>Bayes rule</h4><p>$$p(x|y)p(y)=p(y|x)p(x) \Longrightarrow p(y|x)=\frac{p(x|y)p(y)}{p(x)}=\frac{p(x|y)p(y)}{\int p(x,y) dy} = \frac{p(x|y)p(y)}{\int p(x|y)p(y)dy}$$</p>
<h4 id="Independence"><a href="#Independence" class="headerlink" title="Independence"></a>Independence</h4><p>independence of X and Y means that every conditional distribution is the same.</p>
<p>when variables are independent, $p(x,y)=p(x|y)p(y)=p(x)p(y)$</p>
<h4 id="Expectation"><a href="#Expectation" class="headerlink" title="Expectation"></a>Expectation</h4><p>$E[f(x)]=\sum\limits_x f(x)p(x)\ \text{or} \ \int f(x)p(x)dx$</p>
<p>$E[f(x)+g(x)]=E[f(x)]+E[g(x)]$     </p>
<p>$E[f(x)g(x)]=E[f(x)]E[g(x)]$(if X, Y independent)</p>
<h3 id="Probability-Distribution"><a href="#Probability-Distribution" class="headerlink" title="Probability Distribution"></a>Probability Distribution</h3><table>
<thead>
<tr>
<th>Data Type</th>
<th>Domain</th>
<th>Distributions</th>
<th>PDF(PMF)</th>
<th>Parameter</th>
</tr>
</thead>
<tbody><tr>
<td>Univariate, discrete, binary</td>
<td>$x\in{0,1}$</td>
<td>Bernoulli</td>
<td>$p(x)=\lambda^x(1-\lambda)^{1-x}$</td>
<td>$\lambda$</td>
</tr>
<tr>
<td>Univariate, discrete, multi-valued</td>
<td>$x\in{1,2,\cdots,K}$</td>
<td>Categorical</td>
<td>$p(\mathbb{x})=\prod\limits_{k=1}^K \lambda_k^{x_k}=\lambda_k$</td>
<td>$\lambda=[\lambda_1,\cdots,\lambda_K]^T$, where $\lambda\geq 0$, $\sum_k\lambda_k=1$</td>
</tr>
<tr>
<td>Univariate, continuous, unbounded</td>
<td>$x\in R$</td>
<td>Univariate normal (Gaussian)</td>
<td>$p(x</td>
<td>\mu,\sigma^2)=\frac{1}{\sqrt{2\pi\sigma^2}} \exp -\frac{(x-\mu)^2}{2\sigma^2}$</td>
</tr>
<tr>
<td>Univariate, continuous, bounded</td>
<td>$x\in [0,1]$</td>
<td>Beta</td>
<td>$p(x)=\frac{\Gamma[\alpha+\beta]}{\Gamma[\alpha]\Gamma[\beta]} x^{\alpha-1}(1-x)^{\beta-1}$</td>
<td>$\alpha$, $\beta$</td>
</tr>
<tr>
<td>Multivariate, continuous, unbounded</td>
<td>$\mathbf{x}\in \mathbb{R}^D$</td>
<td>Multivariate normal</td>
<td>$\frac{1}{(2\pi)^{D/2}</td>
<td>\boldsymbol{\Sigma}</td>
</tr>
<tr>
<td>Multivariate, continuous, bounded, sum to 1</td>
<td>$\mathbf{x}=[x_1,x_2,\cdots,x_K]^T$, $x_k\in[0,1]$, $\sum\limits_{k=1}^K x_k=1$</td>
<td>Dirichlet</td>
<td>$p\left(\mathbb{x}\right)=\frac{\Gamma\left[\sum_{k=1}^{K} \alpha_{k}\right]}{\prod_{k=1}^{K} \Gamma\left[\alpha_{k}\right]} \prod_{k=1}^{K} x_{k}^{\alpha_{k}-1}$</td>
<td>$\alpha_k$ (k个)</td>
</tr>
<tr>
<td>Bivariate, continuous, $x_1$ unbounded, $x_2$ bounded below</td>
<td>$\mathbf{x}=[x_1, x_2]$, $x_1\in\mathbb{R}$, $x_2\in\mathbb{R}^+$</td>
<td>Normal-scaled inverse gamma</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Multivariate vector $\mathbf{x}$ and matrix $\mathbf{X}$. $\mathbf{x}$ Unbounded, $\mathbf{X}$ square, positive definite</td>
<td>$\mathbf{x}\in\mathbb{R}^K$, $\mathbf{X}\in\mathbb{R}^{K\times K}$, $\mathbf{z}^T\mathbf{X}\mathbf{z}&gt;0\quad \forall\mathbf{z}\in\mathbb{R}^K$</td>
<td>Normal inverse Wishart</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p><strong>Conjugate Distributions</strong></p>
<ul>
<li><p>Parameters of conjugate distributions are known as hyperparameters because they control the parameter distribution</p>
</li>
<li><p><strong>Aim:</strong> Learning the parameters $\theta$ of a probability distribution:</p>
<p>​    $$p(\theta|x)=\frac{p(x|\theta)p(\theta)}{\int p(x|\theta)p(\theta)d\theta}$$</p>
<ul>
<li>$p(\theta)$: prior.  $p(x|\theta)$: likelihood.  $p(\theta|x)$: posterior</li>
<li>Use prior and likelihood to compute posterior. Posterior has the same form as prior $\longrightarrow$ conjugate</li>
</ul>
</li>
<li><p>使用共轭先验的原因是，可以使得先验分布和后验分布的形式相同，这样符合人的直观感受，另一方面，是可以形成一个先验链，即现在的后验分布可以作为下一次计算的先验分布，也就是带来了计算的简单性。</p>
</li>
<li><p>使得Bayes inference更加方便， 比如在 sequential Bayesian inference中，得到一个observation之后，可以算出一个posterior。由于选取的是conjugate prior，因此posterior和prior的形式一样，可以把该posterior当作新的prior，用于下一次的observation，继续下一次迭代。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Distribution</th>
<th>Domain</th>
<th>Prior</th>
<th>Prior Distribution</th>
<th>hyper parameters</th>
</tr>
</thead>
<tbody><tr>
<td>Bernouli</td>
<td>$x\in{0,1}$</td>
<td>Beta</td>
<td>$p(\lambda)=\frac{\Gamma[\alpha+\beta]}{\Gamma[\alpha]\Gamma[\beta]}\lambda^{\alpha-1}(1-\lambda)^{\beta-1}$, $\lambda\in[0,1]​$</td>
<td>$\alpha$, $\beta​$</td>
</tr>
<tr>
<td>Binomial</td>
<td>$x\in{0,1,\cdots,n}$</td>
<td>Beta</td>
<td>$p(\lambda)=\frac{\Gamma[\alpha+\beta]}{\Gamma[\alpha]\Gamma[\beta]}\lambda^{\alpha-1}(1-\lambda)^{\beta-1}$, $\lambda\in[0,1]$</td>
<td>$\alpha$, $\beta$</td>
</tr>
<tr>
<td>Categorical</td>
<td>$x\in {1, 2, \cdots,K}$</td>
<td>Dirichlet</td>
<td>$p\left(\lambda_{1}, \ldots, \lambda_{K}\right)=\frac{\Gamma\left[\sum_{k=1}^{K} \alpha_{k}\right]}{\prod_{k=1}^{K} \Gamma\left[\alpha_{k}\right]} \prod_{k=1}^{K} \lambda_{k}^{\alpha_{k}-1}$</td>
<td>k 个 $\alpha_k&gt;0$</td>
</tr>
<tr>
<td>Univariate normal (Given Variance, mean unknot)</td>
<td></td>
<td>Univariate normal</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Univariate normal (Given Mean, Variance unknown)</td>
<td></td>
<td>Gamma</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Univariate normal (Both Variance and Mean unknown)</td>
<td>$x\in\mathbb{R}$</td>
<td>normal inverse gamma</td>
<td>$p\left(\mu, \sigma^{2}\right)=\frac{\sqrt{\gamma}}{\sigma \sqrt{2 \pi}} \frac{\beta^{\alpha}}{\Gamma[\alpha]}\left(\frac{1}{\sigma^{2}}\right)^{\alpha+1} \exp \left[-\frac{2 \beta+\gamma(\delta-\mu)^{2}}{2 \sigma^{2}}\right]$</td>
<td>$\alpha, \beta, \gamma&gt;0, \text{and}\ \delta\in\mathbb{R}$</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Multivariate normal</td>
<td>$\mathbf{x}\in\mathbb{R}^k$</td>
<td>normal inverse Wishart</td>
<td>$p(\boldsymbol{\mu}, \boldsymbol{\Sigma})=\frac{\gamma^{D / 2}</td>
<td>\mathbf{\Psi}</td>
</tr>
</tbody></table>
<blockquote>
<p>Gamma Function:</p>
<p> $\Gamma(z)=\int_0^{\infty} t^{z-1}e^{-t} dt, \quad z\in \mathbb{C}$;  </p>
<p>$\Gamma(n)=(n-1)!,\quad n\in\mathbb{Z}_{&gt;0}$ </p>
</blockquote>
<blockquote>
<p>Binomial distribution: $p(x)=\left( \begin{array}{l}{n} \ {x}\end{array}\right) \lambda^{x}(1-\lambda)^{n-x}$</p>
<p>Categorical distribution: $p(\mathbb{x})=\prod\limits_{k=1}^K \lambda_k^{x_k}=\lambda_k$</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26638720">https://zhuanlan.zhihu.com/p/26638720</a></p>
</blockquote>
</li>
</ul>
<h1 id="Fitting-Probability-Models"><a href="#Fitting-Probability-Models" class="headerlink" title="Fitting Probability Models"></a>Fitting Probability Models</h1><p>we already know some common parametric probability distributions $p(x|\theta)$. </p>
<p>Now, we need to know how to <u><strong>learn unknown parameters $\theta$</strong></u> from given data $\mathcal{D}={x[1],\cdots,x_[N]}$. Then, <u><strong>use these parameters to make prediction</strong></u>.</p>
<h2 id="Learning"><a href="#Learning" class="headerlink" title="Learning"></a>Learning</h2><p><strong>Methods</strong> to learning the unknown parameters $\theta$ from data</p>
<img src="https://ws3.sinaimg.cn/large/006tNc79gy1g1s5poa8zrj31qi0ssjvq.jpg" style="zoom:30%">

<h3 id="Maximum-Likelihood-Estimation-MLE"><a href="#Maximum-Likelihood-Estimation-MLE" class="headerlink" title="Maximum Likelihood Estimation (MLE)"></a>Maximum Likelihood Estimation (MLE)</h3><ul>
<li><p>Given data $\mathcal{D}={x[1],\cdots,x_[N]}$</p>
</li>
<li><p>Assume:</p>
<ul>
<li>distribution ${p_\theta : \theta \in \Theta}$ where $p(\theta)=p(x|\theta)$</li>
<li>$\mathcal{D}$ is sampled from $X_{1}, X_{2}, \ldots, X_{N} \sim p_{\theta^{<em>}}$ for some $\theta^</em> \in \Theta$</li>
<li>Random variables $X_{1}, X_{2}, \ldots, X_{N}$ are <u><em>i.i.d</em></u></li>
</ul>
</li>
<li><p>Goal: estimate $\theta^*$</p>
</li>
<li><p>Method: estimate $\theta_{MLE}$ is a maximum likelihood estimate (MLE) for $\theta^*$ if  </p>
<p>​    $$\begin{align} \theta_{M L E}&amp;=\underset{\theta \in \Theta}{\operatorname{argmax}}[p(\mathcal{D} | \theta)]\ &amp;=\underset{\theta \in \Theta}{\operatorname{argmax}}[p(x | \theta)]\  &amp;=\underset{\theta}{\operatorname{argmax}}\left[\prod_{i=1}^{N} p(x[i] | \theta)\right] \quad(\text { i.i.d }) \quad \longrightarrow \quad \text{decompose into products of likelihoods}  \end{align} $$</p>
</li>
<li><p>Solution: maximize the logarithm $\theta_{MLE}=\underset{\theta}{\operatorname{argmax}}\left[\log\left(\prod_{i=1}^{N} p(x[i] | \theta)\right)\right]$. Then, solve by taking derivative w.r.t. $\theta$ equal to 0.</p>
</li>
<li><p>Advantages:</p>
<ul>
<li><strong>Easy and fast</strong> to compute</li>
<li>Nice Asymptotic properties**:** <ul>
<li><strong>Consistent</strong>: if data generated from $f(\theta^*)$, MLE converges to its true value, $\hat{\theta}_{MLE} \rightarrow \theta^*$ as $n \rightarrow \infty$ </li>
<li><strong>Efficient</strong>: there is no consistent estimator that has lower mean squared error than the MLE estimate</li>
</ul>
</li>
<li><strong>Functional Invariance:</strong> if $\hat{\theta}$ is the MLE of $\theta^*$, and $g(\theta^*)$is a transformation of $\theta^*$ then the MLE for $\alpha=g(\theta^*)$ is $\hat{\alpha}=g(\hat{\theta})$</li>
</ul>
</li>
<li><p>Disadvantages:</p>
<ul>
<li>MLE is a <u>point estimate</u> i.e., does not represent uncertainty over the estimate </li>
<li>MLE may <u>overfit</u>. </li>
<li>MLE does <u>not incorporate prior information</u>. </li>
<li>Asymptotic results are for the limit and <u>assumes model is correct</u>. </li>
<li>MLE <u>may not exist or may not be unique</u> </li>
<li><strong>not know uncertainty of the parameter estimation</strong></li>
</ul>
</li>
</ul>
<h3 id="Bayesian-Approach"><a href="#Bayesian-Approach" class="headerlink" title="Bayesian Approach"></a>Bayesian Approach</h3><p>To model uncertainty of the parameter estimation</p>
<p><strong>Fitting</strong>: Instead of a point estimate $\hat{\theta}$, compute the <u>posterior distribution</u> over all possible parameter values using Bayes’ rule: </p>
<p>​        $$p(\theta | D)=\frac{\prod_{i=1}^{N} p(x[i] | \theta) p(\theta)}{p(D)}$$</p>
<p><strong>Principle</strong>: why pick one set of parameters? There are many values that could have explained the data. Try to capture all of the possibilities.</p>
<p><strong>Model:</strong></p>
<ul>
<li><p>Goal: Model Uncertainty over $\theta$ using prior distribution </p>
</li>
<li><p>Method: find posterior</p>
<p>​         $p(\theta | D)=\frac{\prod_{i=1}^{N} p(x[i] | \theta) p(\theta)}{p(D)}$</p>
<p>​        $p(\theta | x)=\frac{\prod_{i=1}^{N} p(x[i] | \theta) p(\theta)}{p(x)}=\frac{\prod_{i=1}^{N} p(x[i] | \theta) p(\theta)}{\int \prod_{i=1}^{N} p(x[i] | \theta) p(\theta) d \theta}$</p>
<p>​    where</p>
<p>​        $\prod_{i=1}^{N} p(x[i] | \theta) p(\theta)=\prod_{i=1}^{N} \operatorname{Norm}<em>{x[i]}\left[\mu, \sigma^{2}\right] \underbrace{\operatorname{NormlnvGam}</em>{\mu, \sigma^{2}}[\alpha, \beta, \gamma, \delta]}_{\text{conjugate prior}}$      if we use Guassian as our observation model, i.e. $p(x|\theta)$</p>
</li>
</ul>
<p>Properties:</p>
<ul>
<li>models uncertainty over parameters.</li>
<li>incorporating prior information</li>
<li>can derive quantities of interest, $p(x&lt;10|D)$</li>
<li>can perform model selection.</li>
</ul>
<p>Drawbacks:</p>
<ul>
<li>Need Prior</li>
<li>Computationally intractable</li>
<li>If initial belief not conjugate to normal likelihood.. bad</li>
</ul>
<h3 id="Maximum-a-Posterior-Estimation-MAP"><a href="#Maximum-a-Posterior-Estimation-MAP" class="headerlink" title="Maximum a Posterior Estimation (MAP)"></a>Maximum a Posterior Estimation (MAP)</h3><p>Given: data $D={x[1], \cdots, x[N]}$</p>
<p>Assume:</p>
<ul>
<li>joint distribution $p(D,\theta)$</li>
<li>$\theta$ is a random variable</li>
</ul>
<p>Goal: Choose “good” $\theta$</p>
<p>Method:</p>
<ul>
<li><p>estimate $\theta_{MAP}$ is a maximum a posterior (MAP) estimation if </p>
<p>$$\begin{align} \theta_{MAP}&amp;=\underset{\theta}{\operatorname{argmax}} [p(\theta|D)]\ &amp;=\underset{\theta}{\operatorname{argmax}}\left[\frac{p(D|\theta)p(\theta)}{p(D)} \right] \quad \text{Bayes’ rule}\&amp;=\underset{\theta}{\operatorname{argmax}}\left[\frac{\prod_{i=1}^N p(x[i]|\theta)p(\theta)}{p(D)} \right]\quad \text{i.i.d}\ &amp;=\underset{\theta}{\operatorname{argmax}}\left[ \prod_{i=1}^N p(x[i]|\theta)p(\theta) \right] \quad p(D)\ \text{ is removed since it is independent of}\ \theta \ \end{align}$$</p>
</li>
<li><p>$ \theta_{MAP} = \underset{\theta}{\operatorname{argmax}}\left[ \prod_{i=1}^N \underbrace{ p(x[i]|\theta)}<em>{\text{likelihood}} \underbrace{p(\theta)}</em>{\text{prior}} \right] $</p>
</li>
<li><p>maximize the logarithm. Then taking derivatieves and setting to zero $\longrightarrow$ parameters estimation</p>
</li>
</ul>
<p>Results:</p>
<ul>
<li>more data points $\rightarrow$ MAP is closer to MLE</li>
<li>Less data points $\rightarrow$ MAP is closer to Prior</li>
</ul>
<p><strong>key steps:</strong></p>
<ol>
<li><p>Prior distribution</p>
</li>
<li><p>Derive<br>$$<br>\mathcal{L}=\log p(D | \theta) p(\theta)=\log p(D | \theta)+\log p(\theta)<br>$$</p>
</li>
<li><p>Then set $\frac{\part L}{\part \theta_i}=0$ for each parameter $\theta_i$</p>
</li>
</ol>
<p>Properties:</p>
<ul>
<li>Fast and easy</li>
<li>incorporate prior information</li>
<li><font color=#0099ff size=4 face="robot">Avoid overfitting (“regularization”) ?</font></li>
<li>As $n \rightarrow \infty$, MAP tends to look like MLE, but not have same nice asympototic properties.</li>
</ul>
<p>Drawbacks:</p>
<ul>
<li><strong>Point estimation</strong> (like MLE)<ul>
<li>not capture uncertainty over estimates</li>
</ul>
</li>
<li>NEED to choose Prior.</li>
<li>Not functionally invariant:<ul>
<li>if $\hat{\theta}$ is the MLE of $\theta^*$, and $g(\theta^*)$ is a transformation of $\theta^*$, then the MAP for $\alpha = g(\theta^*)$ is not necessarily $\hat{\alpha} = g(\hat{\theta})$</li>
</ul>
</li>
</ul>
<h2 id="Prediction"><a href="#Prediction" class="headerlink" title="Prediction"></a>Prediction</h2><ul>
<li><p>MLE / MAP: evaluate new data point under parameter learnt by MLE /MAP.</p>
</li>
<li><p>Bayesian: calculate weighted sum of predictions from all possible values of parameters:<br>$$<br>\begin{aligned} p\left(x^{<em>} | \mathcal{D}\right) &amp;=\frac{p\left(x^{</em>}, D\right)}{p(D)} \quad \text{(conditional probability)} \ &amp;=\frac{\int p\left(x^{<em>}, D, \theta\right) d \theta}{p(D)} \quad \text{(marginal probability)} \ &amp;=\frac{\int p\left(x^{</em>}, \theta | D\right) p(D) d \theta}{p(D)} \quad \text{(conditional probability)} \ &amp;=\int p\left(x^{<em>} | D, \theta\right) p(\theta | D) d \theta \quad \text{(conditional probability)} \ &amp;=\int p\left(x^{</em>} | D\right) p(\theta | D) d \theta  \quad \text{(conditional independence)} \end{aligned}<br>$$</p>
</li>
<li><p><strong>Predictive Density</strong></p>
<ul>
<li><p>$$<br>p\left(x^{<em>} | D\right)=\int \underbrace{p\left(x^{</em>} | \theta\right)}<em>{\text{weights}} \underbrace{p(\theta | D) d \theta}</em>{\text{prediction for each possible}\ \theta}<br>$$</p>
<blockquote>
<p>Make a prediction that is an infinite weighted sum (integral) of the predictions for each parameter value, where weights are probabilitys. </p>
</blockquote>
<blockquote>
<p> consider MLE and MAP estimates as probability distributions with zero probability everywhere except at estimate </p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>Training data decrease, Bayesian become less certain, but MAP is wrongly overconfident.</p>
<h2 id="Exponential-Family"><a href="#Exponential-Family" class="headerlink" title="Exponential Family"></a>Exponential Family</h2><p>exponential family:</p>
<ul>
<li><p>a set of probability distributions ${p_\theta: \theta \in \Theta}$ with the form<br>$$<br>p_{\theta}(x)=\frac{h(x) \exp \left[-\eta(\theta)^{\top} s(x)\right]}{Z(\theta)}<br>$$<br>Where </p>
<ul>
<li>$\theta \in \mathbb{R}^{k}, x \in \mathbb{R}^{d}$</li>
<li>natural parameters $\eta(\theta) : \Theta \rightarrow \mathbb{R}^m$</li>
<li>sufficient statistics: $s(x): \mathbb{R}^d \rightarrow \mathbb{R}^m$</li>
<li>base measure (supporting and scaling) : $h(x):\mathbb{R}^d \rightarrow [0,\infty)$</li>
<li>partition function: $Z(\theta):\Theta \rightarrow [0,\infty)$</li>
</ul>
</li>
</ul>
<p>an exponential family is in its <em><u><strong>natural (canonical 标准的) form</strong></u></em> if it is parameterized by its <u>natural parameters $\eta$ :</u><br>$$<br>p_{\eta}(x)=p(x | \eta)=\frac{h(x) \exp \left[-\eta^{\top} s(x)\right]}{Z(\eta)}<br>$$<br><u><em><strong>Normaliser</strong></em></u>: $Z(\eta)$<br>$$<br>Z(\eta)=\int h(x) \exp \left[-\eta^{\top} s(x)\right] d x<br>$$<br>Properties:</p>
<ul>
<li>has conjugate prior. </li>
<li>fixed number of sufficient statistics that summarize iid data. 指数函数的充分统计量的可以从大量的i.i.d.数据中归结为估计的几个值（即 $s (x)$ )</li>
<li>Posterior predictive distribution always has closed form solution </li>
<li>共轭先验性质给出了后验概率分布的闭式解，否则我们需要求解复杂的积分。而且，共轭先验使得我们能够清楚的看到似然函数对概率分布的影响。</li>
</ul>
<p>For any ExpFam:<br>$$<br>\mathbb{E}[s(x)]=\nabla \log \mathrm{Z}(\eta)<br>$$</p>
<ul>
<li>通过对$Z(\eta)$求导，容易得到充分统计量$s(x)$的均值，方差和其他性质。</li>
</ul>
<p><strong>Important Properties:</strong> </p>
<img src="https://ws1.sinaimg.cn/large/006tNc79gy1g1wgc7mwjuj30s108tn0d.jpg" style="zoom:80%">

<p>Many distributions are Exponential Family:</p>
<table>
<thead>
<tr>
<th>PMF</th>
<th>PDF</th>
</tr>
</thead>
<tbody><tr>
<td>• Bernoulli<br/>• Binomial</td>
<td></td>
</tr>
<tr>
<td>• Categorical/Multinoulli</td>
<td></td>
</tr>
<tr>
<td>• Poisson</td>
<td></td>
</tr>
<tr>
<td>• Multinomial</td>
<td></td>
</tr>
<tr>
<td>• Negative Binomial<br/>• Negative Binomial</td>
<td>• Normal<br/>• Gamma &amp; Inverse Gamma</td>
</tr>
<tr>
<td>• Wishart &amp; Inverse Wishart</td>
<td></td>
</tr>
<tr>
<td>• Beta</td>
<td></td>
</tr>
<tr>
<td>• Dirichlet</td>
<td></td>
</tr>
<tr>
<td>• lognormal</td>
<td></td>
</tr>
<tr>
<td>• Exponential</td>
<td></td>
</tr>
<tr>
<td>•…</td>
<td></td>
</tr>
</tbody></table>
<h1 id="Bayesian-Networks"><a href="#Bayesian-Networks" class="headerlink" title="Bayesian Networks"></a>Bayesian Networks</h1><h2 id="Conditional-Independence"><a href="#Conditional-Independence" class="headerlink" title="Conditional Independence"></a>Conditional Independence</h2><p>Fitting probability models <font color=#0099ff size=2 face="黑体">(learning)</font> and predictive density <font color=#0099ff size=2 face="黑体">(inference)</font></p>
<ul>
<li>BUT just at the case of One random variables, i.e. $p(x|\theta)$</li>
<li>How about joint probability with $N$ random variables?</li>
</ul>
<p><strong>Problem:</strong></p>
<ul>
<li><p>Assume $N$ discrete random variables $x_1, \cdots, x_N$, where $x_i\in{1,\cdots,K}$.  $\longrightarrow$ need $O(K^N)$ parameters to represent the joint distribution $p(x_1, \cdots, x_N)$ $\longrightarrow$ hard to infer, need huge amount of data to learn all parameters</p>
</li>
<li><p>If all random variables are independent  $\longrightarrow$  $O(NK)$ with $p(x_1,\cdots, x_N|\theta) = \prod_{i=1}^N p(x_i|\theta_i)$   $\longrightarrow$    can infer, smaller data</p>
</li>
</ul>
<img src="https://ws2.sinaimg.cn/large/006tNc79gy1g1wivh3gerj31c50u043s.jpg" style="zoom:30%">

<p>###<strong>Definition:</strong></p>
<p>Two random variables $X_A$ and $X_C$ are conditionally independent given $X_B$, $X_{A} \perp X_{C} | X_{B}$  iff $p\left(x_{A}, x_{C} | x_{B}\right)=p\left(x_{A} | x_{B}\right) p\left(x_{C} | x_{B}\right)$  OR $p\left(x_{A} | x_{B}, x_{C}\right)=p\left(x_{A} | x_{B}\right), \quad \forall X_{B} : p\left(x_{B}\right)&gt;0$, which means learning $X_C$ does not change prediction of $X_A$ once we know the value of $X_B$.</p>
<p>###<strong>Meanings</strong>:</p>
<ul>
<li>parameter reduction<ul>
<li>let $m_i$ denotes the number of parents of node $X_i$, and each node takes on $K$ values.</li>
<li>conditional probability of $X_i$ use $K^{m_i+1}$ parameters</li>
<li>Sum for all nodes, parameter reduction from $O(K^N)$ to $O(K^{m+1})$, and $m \ll N$</li>
</ul>
</li>
</ul>
<h3 id="Learning-with-conditional-independence-MLE"><a href="#Learning-with-conditional-independence-MLE" class="headerlink" title="Learning  with conditional independence: MLE"></a>Learning  with conditional independence: MLE</h3><ol>
<li><p>represent the joint probability distribution</p>
</li>
<li><p>Taking the logarithm of $p(x|\theta)$  converts the product into sums</p>
</li>
<li><p>find the maximum log-likelihood of each parameter $\theta_i$ .  this can be executed seperatively.</p>
<p>$\underset{\theta_1}{\operatorname{argmax} \log p(x|\theta)}$,     $\underset{\theta_2}{\operatorname{argmax} \log p(x|\theta)}$,     $\cdots$,     <em>[other random varibles which independent of $\theta-1$ can be removed.]</em></p>
</li>
</ol>
<h3 id="Learning-with-conditional-independence-MAP"><a href="#Learning-with-conditional-independence-MAP" class="headerlink" title="Learning with conditional independence: MAP"></a>Learning with conditional independence: MAP</h3><p>Similar as MLE:<br>$$<br>\begin{aligned} \underset{\theta_{i}}{\operatorname{argmax}} \log p(\theta | x) &amp;=\underset{\theta_{i}}{\operatorname{argmax}} \log p(x | \theta) p(\theta) \ &amp;=\underset{\theta_{i}}{\operatorname{argmax}}\left{\log p\left(x_{i} | x_{\pi_{i}}, \theta_{i}\right)+\log p\left(\theta_{i}\right)\right} \end{aligned}<br>$$<br>where $\theta=\left(\theta_{1}, \ldots, \theta_{M}\right)$</p>
<h2 id="Bayesian-Networks-1"><a href="#Bayesian-Networks-1" class="headerlink" title="Bayesian Networks"></a>Bayesian Networks</h2><ul>
<li><p>Bayesian Network is a DAG $\mathcal{G}$  (no cycle)</p>
<ul>
<li>node is variables $X_i$,   set of parent nodes $X_{\pi_i}$: all variables that are parents of $X_i$</li>
<li>Topological ordering: if $X_i \rightarrow X_j$, then $i&lt;j$  [not unique]</li>
</ul>
</li>
<li><p><strong>Path</strong>: {path follow the arrows cosidering direction}.      V.S.    <strong>Trail</strong>: {path follow the edges without considering the direction}</p>
</li>
<li><p><strong>Ancestors</strong>: parents, grand-parents , etc.     V.S.      <strong>Descendants</strong>: children, grand-children, etc.</p>
</li>
<li><p><em><strong>Local Markov assumption :</strong></em></p>
<ul>
<li><p>Each random variable  $X_i$ is independent of its non-descendants $X_{nonDesc(X_i)}$ given its parents $X_{\pi_i}$ </p>
</li>
<li><p>$$<br>\left{X_{i} \perp\left(X_{\text { nonDesc }\left(X_{i}\right)} \backslash X_{\pi_{i}}\right) | X_{\pi_{i}}\right}<br>$$</p>
</li>
<li><p>Given parents, $X_i$ 与 非后代 $X_{nonDesc(X_i)}$ 独立。</p>
</li>
<li><p>Then, <em><u>conditional probability</u></em>  $p\left(x_{i} | x_{\pi_{i}}\right), \quad i=1, \cdots,N$  [according to local parent-children relationship]</p>
</li>
</ul>
</li>
</ul>
<p>Joint probability: Product of all local conditional independence<br>$$<br>p\left(x_{1}, \ldots, x_{N}\right)=\prod_{i=1}^{N} p\left(x_{i} | x_{\pi_{i}}\right)<br>$$<br>​    because $p\left(x_{1}, \ldots, x_{N}\right)=p\left(x_{1}\right) \prod_{i=2}^{N} p\left(x_{i} | x_{x_{1}, \ldots, x_{i-1}}\right) \quad \text { (chain rule) }$</p>
<blockquote>
<p>a fully connected DAG can represent <em>any</em>  distribution over its random variables.  </p>
<p>Interprete arrows as “<em>possible</em> dependence”</p>
</blockquote>
<h3 id="Interpreting-Analyzing-Bayesian-Networks"><a href="#Interpreting-Analyzing-Bayesian-Networks" class="headerlink" title="Interpreting/Analyzing Bayesian Networks"></a>Interpreting/Analyzing Bayesian Networks</h3><ul>
<li>already know the conditional independence based on local parent-children relationship.</li>
<li>hope to know other extra independece</li>
</ul>
<p>Methods：</p>
<ol>
<li>prove $p\left(x_{A}, x_{C} | x_{B}\right)=p\left(x_{A} | x_{B}\right) p\left(x_{C} | x_{B}\right)$  OR $p\left(x_{A} | x_{B}, x_{C}\right)=p\left(x_{A} | x_{B}\right), \quad \forall X_{B} : p\left(x_{B}\right)&gt;0$  for $X_{A} \perp X_{C} | X_{B}$  </li>
<li>Graph seperation</li>
</ol>
<h3 id="Graph-seperation"><a href="#Graph-seperation" class="headerlink" title="Graph seperation"></a>Graph seperation</h3><p>Precise definition of <em><strong>“blocking”</strong></em> has to be done through the  <u>“three canonical 3-node graphs”</u>, and <u>“d-separation”</u>. </p>
<p><u><strong>Three canonical 3-node graphs:</strong></u></p>
<img src="https://ws3.sinaimg.cn/large/006tNc79gy1g1wr8wvaqnj316g0u0wip.jpg" style="zoom:30%">

<ul>
<li><p>Head-Tail</p>
<ul>
<li><p>if none variables are observed, A and B are not independent $A \notperp B | \emptyset$<br>$$<br>p(a, b)=p(a) \sum_{c} p(c | a) p(b | c)=p(a) p(b | a)<br>$$</p>
</li>
<li><p>if C observed, using Bayes’ rule, obtain $A \perp B | C$<br>$$<br>\begin{aligned} p(a, b | c) &amp;=\frac{p(a, b, c)}{p(c)} \ &amp;=\frac{p(a) p(c | a) p(b | c)}{p(c)} \ &amp;=p(a | c) p(b | c) \end{aligned} \quad \text { (Bayes rule) }<br>$$</p>
<img src="https://ws3.sinaimg.cn/large/006tNc79gy1g1wrn49rwlj31r40hqdiq.jpg" style="zoom:30%"></li>
<li><p>Intuition: past A is independent of future B given present C, $\rightarrow$  simple Markov Chain</p>
</li>
</ul>
</li>
<li><p>Tail-Tail</p>
<ul>
<li><p>If none variables are observed, NOT independent, $A \notperp B | \emptyset$</p>
</li>
<li><p>If C observed, obtain $A  \perp  B | C$ , because</p>
</li>
<li><p>$$<br>\begin{aligned} p(a, b | c) &amp;=\frac{p(a, b, c)}{p(c)} \ &amp;=p(a | c) p(b | c) \end{aligned}<br>$$</p>
</li>
<li><p>Then,</p>
<img src="https://ws4.sinaimg.cn/large/006tNc79gy1g1wrvlq93nj31jc0ie41z.jpg" style="zoom:30%"></li>
</ul>
</li>
<li><p>Head-Head</p>
<ul>
<li><p>if none variables observed, we obtain <strong>$A \perp B | \emptyset$</strong>  because<br>$$<br>p(a, b)=p(a) p(b)<br>$$</p>
</li>
<li><p>if C observed, we obtain $A \notperp B | C$ , because<br>$$<br>\begin{aligned} p(a, b | c) &amp;=\frac{p(a, b, c)}{p(c)} \ &amp;=\frac{p(a) p(b) p(c | a, b)}{p(c)} \end{aligned}<br>$$<br>​    can not obtain $p(a)p(b)$</p>
<img src="https://ws3.sinaimg.cn/large/006tNc79gy1g1ws3foo57j31c20i80vy.jpg" style="zoom:30%"></li>
<li><p>“V-structure”. </p>
</li>
<li><p>if C unobserved, “blocks”. If C observed, “unblocks”.</p>
</li>
<li><img src="https://ws4.sinaimg.cn/large/006tNc79gy1g1ws7oimc0j31aq0qm0ww.jpg" style="zoom:30%"></li>
<li><p><u><strong>Observation of any descendent node of C “unblocks” the path from A to B.</strong></u></p>
</li>
</ul>
<p>$A \perp B |C$ if <u>all trails</u> from nodes in A are “Blocked” from nodes in B when all C are observed. </p>
<p>A is <u><strong>d-separated</strong></u> form B by C</p>
</li>
<li><p>Key: Independence:</p>
<ol>
<li>The arrows on the trail meet either <u>head-to-tail</u> or <u>tail-to-tail</u> at the node, and <em>the node</em> is in the set <em>C</em>, or </li>
<li>The arrows meet <u>head-to-head</u> at the node, and <em>neither the node, nor any of its descendants</em>, is in the set <em>C</em>. </li>
</ol>
</li>
</ul>
<h3 id="Bayes-Ball"><a href="#Bayes-Ball" class="headerlink" title="Bayes Ball"></a>Bayes Ball</h3><ul>
<li><p>it’s a <strong>“reachability” algorithm”:</strong></p>
<ol>
<li>shade the nodes in set $C$ (given nodes)</li>
<li>Place a ball at each of the nodes in set $A$</li>
<li>Let the balls “bounce around” the graph according to the d-separation rules:<ul>
<li>if none of the balls reach B, then $A \perp B|C$</li>
<li>Else $A \norperp B|C$</li>
</ul>
</li>
</ol>
</li>
<li><p>can be implement as a <em>breadth-first search</em></p>
</li>
<li><p><strong>procedure of algorithm:</strong></p>
<ul>
<li>given Graph $G$ and sets of nodes $X, Y$, and $Z$</li>
<li>Output True if $X\perp Y | Z$, False otherwise.</li>
<li>2 Phases:<ul>
<li>Phase 1: “Find all the unblocked v-structures”<ul>
<li>traverse the graph from the leaves to the roots, marking all nodes that are in $Z$ or have descendants in $Z$.</li>
</ul>
</li>
<li>Phase 2: “Traverse all the trails starting from $X$”<ul>
<li>apply breadth-first-search, stopping a specific traversal when we hit a blocked node.</li>
<li>If $Y$ is reached during. this traversal, return False. Else, return True.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Bayes-Network-Examples"><a href="#Bayes-Network-Examples" class="headerlink" title="Bayes Network Examples:"></a>Bayes Network Examples:</h2><h3 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h3><ul>
<li><p>Model:</p>
<ul>
<li><p>$$<br>Y[i]=\mathbf{w}^{\top} \mathbf{x}[i]+\epsilon[i]<br>$$</p>
</li>
<li><p>where input vector: $\mathbf{x}[i]=\left[\mathrm{x}[i]<em>{1}, \mathrm{x}[i]</em>{2}, \ldots, \mathrm{x}[i]<em>{\mathrm{D}}\right]^{\top}$; coeffiecient vector: $\mathbf{w}=\left[w</em>{1}, w_{2}, \ldots, w_{D}\right]^{\top}$; noise: $\epsilon[i] \sim N\left(0, \sigma_{n}^{2}\right)$</p>
</li>
<li><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1g1z3hfsl4aj30eq0segmy.jpg" style="zoom:30%">   $\Longrightarrow$ <img src="https://ws1.sinaimg.cn/large/006tNc79gy1g1z3ldzy0gj30fu0lq3zg.jpg" style="zoom:30%"></p>
</li>
<li><p>if $\epsilon \sim N\left(0, \sigma_{n}^{2}\right)$ , then $Y \sim N\left(\mathbf{w}^{\top} \mathbf{x}, \sigma_{n}^{2}\right)$</p>
</li>
<li><p>Affine property of Gaussian:</p>
<ul>
<li>$f(x)=ax+b$ of Gaussian, $\rightarrow$ , new PDF $\mathcal{N}(a\mu+b,a^2\sigma^2)$</li>
</ul>
</li>
<li><p>Independence assertion:<br>$$<br>Y[i] \perp Y[i+1] |\mathbb{x}[i], \mathbb{w}, \sigma_n^2<br>$$<br>write the factorization:<br>$$<br>p(y[1],\cdots,y[N])=\prod\limits_i^N p(y[i]| \mathbb{w}^\top\mathbb{x}[i], \sigma_n^2)<br>$$</p>
</li>
<li><p><strong>Problem: Assume we know $\sigma_n^2$, how to learn unknown parameter $\mathbb{w}$?</strong></p>
<ul>
<li>Approach 1: MLE</li>
</ul>
<p>$$<br>\theta_{MLE}=\underset{\theta}{\operatorname{argmax}}\left[\prod_{i=1}^{N} p(x[i] | \theta)\right] \quad \text{iid}<br>$$</p>
<p>​        with $p\left(x | \mu, \sigma^{2}\right)=\operatorname{Norm}_{x}\left[\mu, \sigma^{2}\right]=\frac{1}{\sqrt{2 \pi \sigma^{2}}} \exp -\frac{(x-\mu)^{2}}{2 \sigma^{2}}$</p>
<p>​    logarithm, and compute derivate for $\mathbb{w}$<br>$$<br>\log \prod_{i=1}^{N} p(y[i]| \mathbb{w}^\top\mathbb{x}[i], \sigma_n^2) = \sum_{i=1}^N \log \mathcal{N}([i]| \mathbb{w}^\top\mathbb{x}[i], \sigma_n^2)\<br>\propto-\sum_{i=1}^N \frac{(y[i]-\mathbb{w}^\top x[i])^2}{2\sigma_n^2}<br>$$<br>​    So,<br>$$<br>\underset{\theta}{\operatorname{argmin}} \sum\limits_{i=1}^N \frac{(y[i]-\mathbb{w}^\top x[i])^2}{2\sigma_n^2} = \frac{1}{2\sigma_n^2} \underset{\theta}{\operatorname{argmin}}(\mathbf{Y}-\mathbf{X}^\top \mathbb{w})^\top (\mathbf{Y}-\mathbf{X}^\top \mathbb{w})<br>$$<br>​    Set $\mathcal{L}(\mathbb{w})=\mathbf{Y}-\mathbf{X}^\top \mathbb{w})^\top (\mathbf{Y}-\mathbf{X}^\top \mathbb{w})$<br>$$<br>\nabla \mathcal{L}(\mathbb{w})=(\mathbb{w}^\top(\mathbf{X}^\top\mathbf{X})-\mathbf{Y}^\top\mathbf{X}) = 0\<br>\text{so,} \quad \mathbb{w}=(\mathbf{X}\top\mathbf{X})^{-1}\mathbf{X}^\top\mathbf{Y}<br>$$<br><font color=#0099ff size=3 face="黑体">对ppt有疑问，手写的那一页， p41 </font></p>
</li>
</ul>
</li>
<li><p>**Model Uncertainty of $\mathbb{w}$ **</p>
<ul>
<li><p>Model:</p>
<img src="https://ws3.sinaimg.cn/large/006tNc79gy1g1zu068f7cj30j00pu400.jpg" style="zoom:30%">

<ul>
<li><p>$p(\mathbf{w} | v)=N(\mathbf{0}, v \mathbf{I})$</p>
</li>
<li><p>Conditional independence assertation:<br>$$<br>p(y[1], \ldots, y[N], \mathbf{w}) =p(\mathbf{w} | v) \prod\limits_{i}^N p(y[i]| \mathbf{w}^{\top} \mathbf{x}[i], \sigma_{n}^{2} )<br>$$</p>
</li>
</ul>
</li>
<li><p><strong>Problem: assume know $\sigma_n^2$, MAP solution of $\mathbb{w}$</strong></p>
<ul>
<li><p>Same as MLE, derivative, equal to 0. </p>
</li>
<li><p>$$<br>\mathbb{w}=(\mathbf{Y}^\top\mathbf{X}+2\lambda)^{-1}\mathbf{X}^\top\mathbf{Y},\quad\text{where}\ \lambda=\frac{\sigma_n^2}{v}<br>$$</p>
</li>
<li><p>if prior is laplacian distribution: $p(\mathbb{w}|0,b)=\frac{1}{2b}\exp (-\frac{|w|}{b})$</p>
<ul>
<li>$\log p(\mathbb{w}|0,b)\propto -\frac{|w|}{b}$ , then, have $\lambda = -\frac{2\sigma_n^2}{b}$ , form $l_1$-norm. </li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><p>derivative of  $l_0$-norm: This is zero (as you pointed out), but only in places where it isn’t interesting. Where it is interesting it’s not differentiable (it has jump discontinuities).</p>
</li>
<li><p>derivative of $l_1$-norm: This norm is not differentiable with respect to a coordinate where that coordinate is zero. Elsewhere, the partial derivatives are just constants, $\pm 1$ depending on the quadrant.</p>
</li>
<li><p>derivative of $l_2$-norm: Usually people use the $l_2$-norm <em>squared</em> so that it’s differentiable even at zero. The gradient of $||x||^2$ is $2x$, but without the square it’s $\frac{x}{||x||}$ (i.e. it just points away from zero). The problem is that it’s not differentiable <em>at</em> zero.</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>Predictive DGM Model</p>
<img src="https://ws2.sinaimg.cn/large/006tNc79gy1g1zvgeth6yj30so0o80ur.jpg" style="zoom:30%"></li>
</ul>
<h3 id="Naiive-Bayes"><a href="#Naiive-Bayes" class="headerlink" title="Naiive Bayes"></a>Naiive Bayes</h3><ul>
<li><p>Model:</p>
<ul>
<li><p>Class $c \in{1, \ldots, K}$, and input $\mathbf{x}=\left[x_{1}, x_{2}, \ldots, x_{D}\right]^{\top}$</p>
</li>
<li><p>naiive bayes assume that $p(\mathbf{x} | c)=\prod_{j} p\left(x_{j} | c\right)$.         <em>Naive assumption: all features are independent</em></p>
<img src="https://ws1.sinaimg.cn/large/006tNc79gy1g1zzdepvxmj30wm0i8aba.jpg" style="zoom:40%"></li>
<li><p>Filled dots are deterministic parameters.  If we have priors, we can make parameters random variables (open circles)</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g1zzipmzg9j318q0r0jvl.jpg" style="zoom:30%">  $\Longrightarrow$  <img src="https://ws2.sinaimg.cn/large/006tNc79gy1g1zzl4degbj313w0ten0o.jpg" style="zoom:30%"></p>
</li>
<li><p>Even the assumption for naiive bayes is so strong, it still works well?</p>
<ul>
<li><strong>Key idea:</strong> it works well when the local feature dependencies between the two classes “cancel out”.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>##Properties of Bayesian network</p>
<ul>
<li><p>Independence-Maps (I-maps)</p>
<ul>
<li><p>Theorem:</p>
<p>Let $P$ be a joint distribution over $\mathcal{X}$ and $G$ be a Bayesian Network structure over $\mathcal{X}$. If $P$ factories according to $G$, then the <em>local independence assertation</em> $\mathcal{J}_l(G)\subseteq \mathcal{J(P)}$.</p>
<ul>
<li>The <strong>local Markov independence</strong> $\mathcal{J}<em>l(G)$ is the set of all basic conditional independence assertions of the form $\left{X</em>{i} \perp\left(X_{\text { nondesc }\left(x_{i}\right)} \backslash X_{\pi_{i}}\right) | X_{\pi_{i}}\right}$</li>
</ul>
</li>
<li><p>Proof: </p>
<ul>
<li><p>$\mathcal{J}<em>l(G)\subseteq \mathcal{J(P)}$ means $p(X_i|X\setminus X_i)=p(X_i|X</em>{\pi_i})$<br>$$<br>\begin{align}<br>p(X_i|X\setminus X_i)=&amp;\frac{p(X_1, \cdots,X_N)}{P({X_1,\cdots, X_N}\setminus X_i)}\<br>&amp;=\frac{\prod\limits_{i=1}^N p(X_i|X_{\pi_i})}{\sum\limits_{X_i} \prod\limits_j p(X_j|X_{\pi_j})}\<br>&amp;=\frac{p(X_i|X_{\pi_i}) \prod\limits_j p(X_j|X_{\pi_j})}{\sum\limits_{X_i}p(X_i|X_{\pi_i}) \prod\limits_j p(X_j|X_{\pi_j})}\<br>&amp;=\frac{p(X_i|X_{\pi_i})}{\sum\limits_{X_i}p(X_i|X_{\pi_i})} \quad \text{because}\left{\sum\limits_{X_i}p(X_i|X_{\pi_i})=1\right}\<br>&amp;=p(X_i|X_{\pi_i})<br>\end{align}<br>$$</p>
</li>
<li><p>So, $\left{X_{i} \perp\left(X_{\text { nondesc }\left(x_{i}\right)} \backslash X_{\pi_{i}}\right) | X_{\pi_{i}}\right}$</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Global Markov independence:</strong> </p>
<ul>
<li><p>Definition: the set of all independencies that correspond to d-seperation in graph $G$ is the set of global Markov independencies:<br>$$<br>\mathcal{J}(G)=\left{(X \perp Y | Z) : \operatorname{dsep}_{\mathrm{G}}(X ; Y | Z)\right}<br>$$</p>
</li>
<li><p><strong>Soundness:</strong></p>
<ul>
<li>Definition: if a distribution $P$ factorizes according to $G$, then $\mathcal{J}_l(G)\subseteq \mathcal{J(P)}$.</li>
<li>i.e. two nodes are d-separated given $Z$, they are conditionally independent given $Z$.</li>
</ul>
</li>
<li><p><strong>Completeness:</strong></p>
<ul>
<li>Definition: $P$ is <strong>faithful</strong> to $G$ if for any conditional independence $(X \perp Y | Z) \in \mathcal{J}(P)$, then $\operatorname{dsep}_{G}(X ; Y | Z)$.</li>
<li>i.e. any independence can be reflect as a d-separation.</li>
<li>Definition: <strong>weak completeness</strong></li>
<li>Definition: <strong>almost completeness</strong></li>
</ul>
</li>
<li><p><strong>How Powerful:</strong></p>
<p>Can find a Bayes network to $G$ represent all conditional independencies for a given $P$?</p>
<ul>
<li>Minimal I-map: “no redundant edges”</li>
<li>perfect map: </li>
</ul>
<p><strong>No</strong></p>
</li>
</ul>
<img src="https://ws1.sinaimg.cn/large/006tNc79gy1g212h03612j30wu0gp0xs.jpg" style="zoom:50%"></li>
</ul>
<h1 id="Undirected-Graphical-Models-Markov-Random-Fields"><a href="#Undirected-Graphical-Models-Markov-Random-Fields" class="headerlink" title="Undirected Graphical Models (Markov Random Fields)"></a>Undirected Graphical Models (Markov Random Fields)</h1><p>##Undirected Graphical Models:</p>
<p>UGM (MRF) or (Markov Network) is graph $\mathcal{G}(\mathcal{V},\mathcal{E})$, set of nodes and set of <u><strong>undirected</strong></u> edges</p>
<ul>
<li><p>Parameterization: via <strong><u>factors</u></strong>.</p>
<ul>
<li>Factor $\varphi(\mathcal{C})$ function map from set of variables to non-negative numbers.</li>
</ul>
</li>
<li><p>Factorization:</p>
<ul>
<li><p>$$<br>p\left(x_{1}, \ldots, x_{N}\right)=\frac{1}{Z} \prod_{j=1}^{M} \varphi_{j}\left(\mathcal{C}_{j}\right)<br>$$</p>
<blockquote>
<p>DGM is $p\left(x_{1}, \ldots, x_{N}\right)=\prod\limits_{i=1}^{N} p\left(x_{i} | x_{i}\right)$</p>
</blockquote>
</li>
</ul>
<img src="https://ws2.sinaimg.cn/large/006tNc79gy1g213c8ln66j317a0u0gwk.jpg" style="zoom:40%">



<ul>
<li>just like DGM, UGM encode a set of conditional independence assertions.</li>
</ul>
</li>
<li><p>Conditional Independence:</p>
<ul>
<li><p>3 Markov properties of UGMs:</p>
<ol>
<li><p><strong>Global Markov Property</strong></p>
<ul>
<li>$X_{A} \perp X_{B} | X_{C}$ iff $C$ separates $A$ from $B$.</li>
<li><u>NO trails connect $A$ and $B$ when remove all nodes in $C$.</u></li>
</ul>
</li>
<li><p><strong>Local Markov Property</strong></p>
<ul>
<li><p>Markov Blanket $\operatorname{mb}(X_s)$: set of nodes that renders a node $X_s$ conditionally independent of all the other nodes:<br>$$<br>X_{S} \perp \overbrace{\mathcal{V} \backslash\left{\mathrm{mb}\left(X_{S}\right), X_{S}\right}}^{\text{all other nodes in}\ G} | \mathrm{mb}\left(X_{S}\right)<br>$$</p>
</li>
<li><p>Markov blanket in UGM is the set of immediate neighbors</p>
<ul>
<li>node 和除了本身以及neighbors 的其他node 都 conditionally independent.  {due to <em>global Markov property</em>}</li>
</ul>
<blockquote>
<p>Markov Blankets for a node $X_s$ in a <u>DGM</u> is the set of node’s parents, children, and co-parents (other parents of children).</p>
</blockquote>
<p><font color=#0099ff size=3 face="黑体">对ppt有疑问， p35 </font></p>
</li>
</ul>
</li>
<li><p><strong>Pairwise Markov Property</strong></p>
<ul>
<li>two nodes $X_s$ and $X_t$ are conditionally independent given the rest if there is no direct edge between them<br>$$<br>X_{s} \perp X_{t} | \mathcal{V} \backslash\left{X_{S}, X_{t}\right}, \text { where } \mathcal{E}_{s t}=\emptyset<br>$$<br>移除其他nodes后无直接连线</li>
</ul>
</li>
</ol>
</li>
<li><p>relationship among  three properties.</p>
<ul>
<li><p><strong>Interrelated.</strong></p>
</li>
<li><p><strong>Global Markov $\Longrightarrow$ local Markov $\Longrightarrow$ Pairwise Markov $\Longrightarrow$ Global Markov</strong></p>
<img src="https://ws3.sinaimg.cn/large/006tNc79gy1g21aej5tedj31jj0u0gwy.jpg" style="zoom:10%">

<ul>
<li>for positive distribution $p(\mathbb{x})&gt;0$, the three Markov properties are equavalent.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Parameterization-of-MRFs"><a href="#Parameterization-of-MRFs" class="headerlink" title="Parameterization of MRFs"></a>Parameterization of MRFs</h2><p>Aim: obtain a local parameterization of UGMs.</p>
<blockquote>
<p>For DGM:</p>
<ul>
<li><p>Local conditional probabilities: $p(x_i|x_{\pi_i})$</p>
</li>
<li><p>Joint probability is product of local conditional probabilities: $p\left(x_{1}, \ldots, x_{N}\right)=\prod_{i=1}^{N} p\left(x_{i} | x_{\pi_{i}}\right)$</p>
</li>
</ul>
</blockquote>
<p>But for UGM, difficult to obtain conditional probabilities since no topological ordering. So, discard conditional probabilities.</p>
<p><strong>Represent the joint as a product of local functions.</strong></p>
<ul>
<li>Normalize</li>
<li>Factors NOT represent marginal/conditional distributions</li>
</ul>
<h3 id="Gibbs-distribution"><a href="#Gibbs-distribution" class="headerlink" title="Gibbs distribution"></a>Gibbs distribution</h3><ul>
<li><p>Definition: A distribution $P$ is a <u>Gibbs distribution</u> parameterized by a set of <u>factors</u> ${\varphi_1(\mathcal{C}<em>1), \varphi_2(\mathcal{C}<em>2),\cdots, \varphi_m(\mathcal{C}<em>m)}$, where<br>$$<br>p\left(x</em>{1}, x</em>{2}, \ldots, x</em>{N}\right)=\frac{1}{Z} \prod_{j=1}^{M} \varphi_{j}\left(\mathcal{C}_{j}\right)<br>$$</p>
</li>
<li><p>Factor:</p>
<blockquote>
<p>Two nodes $X_i$ and $X_j$ that are not directly linked in UGM are <u>conditionally independent</u> given all other nodes. [不直接相连的nodes是条件独立的]</p>
<p>$\rightarrow$ Factorization of joint probability that places $X_i$ and $X_j$ in different factors.</p>
</blockquote>
<p>All nodes $X_C$ in a maximal clique $C$ in UGM form factor (local function) $\varphi(X_C)$</p>
<ul>
<li>Clique: a fully connected subset of nodes.</li>
<li>Maximal Clique $C$: cliques that cannot be extended to include additional nodes </li>
</ul>
<p><strong>Hammersley-Clifford:</strong> a positive distribution $p(y)&gt;0$ satisfies the CI properties of undirected graph $\mathcal{H}$ iff $p$ can be represented as a product of factors, one per maimal clique:</p>
<ul>
<li><p>$$<br>p(\mathbf{y} | \boldsymbol{\theta})=\frac{1}{Z(\boldsymbol{\theta})} \prod_{c \in \mathcal{C}} \psi_{c}\left(\mathbf{y}<em>{c} | \boldsymbol{\theta}</em>{c}\right)<br>$$</p>
<p>where $\mathcal{C}$ is the set of all the maimal liques; $\varphi_C(\cdot)$ is the factor or potential function of clique $c$; $\theta$ is the parameter of factors $\varphi_C(\cdot)$ for $c\in\mathcal{C}$; $Z(\boldsymbol{\theta})$ is the partition function $Z(\boldsymbol{\theta}) \triangleq \sum \prod\limits_{c \in \mathcal{C}} \psi_{c}\left(\mathbf{y}<em>{c} | \boldsymbol{\theta}</em>{c}\right)$.</p>
<blockquote>
<p>UGM <strong>NOT</strong> specify a unique factorization.</p>
<p>Hammersley-Clifford is just one type of factorization.</p>
</blockquote>
</li>
</ul>
<p><strong>Pairwise MRF</strong>:</p>
<ul>
<li>parameretization to the edges of the graph, rather than maximal cliques. [每条边作为factor，不考虑maximal clique]</li>
<li>SIMPLE but not general.</li>
</ul>
</li>
<li><p>Properties:</p>
<ul>
<li><p>Independent set; Independence map (I-map); </p>
</li>
<li><p>Soundness</p>
<ul>
<li>if $P$ is a Gibbs distribution over $H$, then $H$ is an I-map for $P$.<ul>
<li>Hammersley-Clifford states that if $H$ is an I-map for $P$, then $P$ is a Gibbs distribution over $H$ (for positive distribution)</li>
</ul>
</li>
</ul>
</li>
<li><p>Weak completeness</p>
<ul>
<li>if $X$ and $Y$ are not separated in $H$, then there is some distribution $P$ that factories over $H$ where $X$ and $Y$ are dependent.</li>
</ul>
</li>
<li><p>How Powerful: <em>? represent all conditional independencies ?</em></p>
<ul>
<li><p>Perfect map: $\mathcal{J}(G)=\mathcal{J}(P)$</p>
<img src="https://ws3.sinaimg.cn/large/006tNc79gy1g21d9saz2bj30vl0lzgnm.jpg" style="zoom:30%"></li>
<li><p>UGM are NOT “richer” or “more powerful” than DGM.</p>
</li>
</ul>
</li>
</ul>
<img src="https://ws2.sinaimg.cn/large/006tNc79gy1g21ddcvle3j30x50heael.jpg" style="zoom:50%"></li>
<li><p><strong>representing Potential (local) function</strong></p>
<ul>
<li><p>Log potentials is a linear function of parameters:</p>
</li>
<li><p>$$<br>\log \psi_{c}\left(\mathbf{y}<em>{c}\right) \triangleq \phi</em>{c}\left(\mathbf{y}<em>{c}\right)^{T} \boldsymbol{\theta}</em>{c}<br>$$</p>
<p>$\phi_C(y_C)$ is a <u>feature vector</u> derived from the values of the variables $y_C.$</p>
<p>Then, <strong>log probability</strong> is<br>$$<br>\log p(\mathbf{y} | \boldsymbol{\theta})=\sum_{c} \phi_{c}\left(\mathbf{y}<em>{c}\right)^{T} \boldsymbol{\theta}</em>{c}-\log Z(\theta)<br>$$<br>also called <strong>“maximum entropy” or “log-linear” model.</strong></p>
</li>
</ul>
</li>
<li><p>every MRF is an [exponential family](#Exponential Family).</p>
</li>
</ul>
<h2 id="Example-of-MRF"><a href="#Example-of-MRF" class="headerlink" title="Example of MRF"></a>Example of MRF</h2><p>Model:</p>
<ul>
<li>Ising and Potts (Depth Map from Stereo Images (Multi) or Binary Image Denosing)</li>
</ul>
<img src="https://ws1.sinaimg.cn/large/006tNc79gy1g21e3c4a9cj30a407vaar.jpg" style="zoom:70%">
$$
\begin{aligned} p(y, x | J, \theta) =p(\mathbf{y} | J) \prod_{t} p\left(x_{t} | y_{t}, \boldsymbol{\theta}\right) =\left[\frac{1}{Z(J)} \underbrace{\prod_{s \sim t} \psi\left(y_{s}, y_{t} ; J\right)}_{\text{Pairwise Potential}}\right] \underbrace{\prod_{t} p\left(x_{t} | y_{t}, \theta\right)}_{\text{Unary potential}} \end{aligned}
$$
<font color=#0099ff size=3 face="黑体">其实不太懂why </font>

<h2 id="Parameter-Learning"><a href="#Parameter-Learning" class="headerlink" title="Parameter Learning"></a>Parameter Learning</h2><p>UGM (MRF) in <strong>log-linear form</strong>, where $c$ indexes the cliques:<br>$$<br>p(\mathbf{y} | \boldsymbol{\theta})=\frac{1}{Z(\boldsymbol{\theta})} \exp \left(\sum_{c} \boldsymbol{\theta}<em>{c}^{T} \boldsymbol{\phi}</em>{c}(\mathbf{y})\right)<br>$$<br>The <strong><u>scaled log-likelihood</u></strong> is given by<br>$$<br>\ell(\boldsymbol{\theta}) \triangleq \frac{1}{N} \sum_{i}^{N} \log p\left(\mathbf{y}<em>{i} | \boldsymbol{\theta}\right)=\frac{1}{N} \sum</em>{i}^{N}\left[\sum_{c} \boldsymbol{\theta}<em>{c}^{T} \boldsymbol{\phi}</em>{c}\left(\mathbf{y}_{i}\right)-\log Z(\boldsymbol{\theta})\right]<br>$$</p>
<ul>
<li><p>belongs to exponential family, </p>
</li>
<li><p><em><strong>convex</strong></em> function in $\theta$, so can find unique global maximum by gradient-based optimizers.</p>
</li>
<li><p>$$<br>\frac{\partial \ell}{\partial \boldsymbol{\theta}<em>{c}}=\frac{1}{N} \sum</em>{i}^{N}\left[\boldsymbol{\phi}<em>{c}\left(\mathbf{y}</em>{i}\right)-\frac{\partial}{\partial \boldsymbol{\theta}_{c}} \log Z(\boldsymbol{\theta})\right]<br>$$</p>
<p><font color=#0099ff size=3 face="黑体">对ppt有疑问， p96， 怎么求的导？ </font></p>
</li>
<li><p>for exponential family distribution:</p>
<ul>
<li><p>$$<br>\mathbb{E}[s(x)]=\nabla \log Z(\eta)<br>$$</p>
</li>
<li><p>if $s(x)=x$ (natural exponential family), we can find moments of $x$ simply by differentiation.</p>
</li>
<li><p>the derivative of the log partition function w.r.t. $\theta_c$ is the expectation of the $c^{th}$ feature under the model:</p>
</li>
<li><p>$$<br>\frac{\partial \log Z(\boldsymbol{\theta})}{\partial \theta_{c}}=\mathbb{E}\left[\phi_{c}(\mathbf{y}) | \boldsymbol{\theta}\right]=\sum_{\mathbf{y}} \phi_{c}(\mathbf{y}) p(\mathbf{y} | \boldsymbol{\theta})<br>$$</p>
</li>
<li><p>Proof: </p>
</li>
<li><p>$$<br>\begin{align}<br>\frac{\partial \log Z(\theta)}{\partial \theta_{c}} &amp;= \frac{1}{Z(\theta)} \frac{\partial Z(\theta)}{\partial \theta_{c}}, \quad \text { where } \quad Z(\theta) = \sum_{y} \exp \left(\sum_{c} \theta_{c}^{T} \phi_{c}(y)\right)\<br>\Rightarrow \frac{\partial Z(\theta)}{\partial \theta_{c}} &amp;= \sum_{y} \exp \left(\sum_{c} \theta_{c}^{T} \phi_{c}(y)\right) \phi_{c}(y)\<br>\Rightarrow \frac{\partial \log Z(\theta)}{\partial \theta_{c}} &amp;= \frac{1}{Z(\theta)} \sum_{y} \phi_{c}(y) \exp \left(\sum_{c} \theta_{c}^{T} \phi_{c}(y)\right) =\sum_{y} \phi_{c}(y) \underbrace{\frac{1}{Z(\theta)} \exp \left(\sum_{c} \theta_{c}^{T} \phi_{c}(y)\right)}<em>{p(y|\theta)} = \sum</em>{y} \phi_{c}(y) p(y | \theta)<br>\end{align}<br>$$</p>
</li>
<li><p>So, the gradient of the log-likelihood is </p>
</li>
<li><p>$$<br>\frac{\partial \ell}{\partial \boldsymbol{\theta}<em>{c}}=\left[\underbrace{\frac{1}{N} \sum</em>{i}^{N} \boldsymbol{\phi}<em>{c}\left(\mathbf{y}</em>{i}\right)}<em>{\text{Clamped term}}\right] - \underbrace{\mathbb{E}\left[\boldsymbol{\phi}</em>{c}(\mathbf{y})\right]}_{\text{Unclamped/contrastive term}}<br>$$</p>
<p>Clamped term: $y$ is fixed to its observed values; Unclamped/contrastive term: $y$ is a free variable.</p>
<p>Unclamped term requires <em><strong>inference</strong></em> in the model, <u>once per gradient step</u>, and this makes UGM learning much <u><strong>slower</strong></u> than DGM. </p>
</li>
<li><p>Gradient of log-likelihood rewrite:</p>
</li>
<li><p>$$<br>\frac{\partial l}{\partial \theta_{c}}=E_{p_{e m p}}\left[\phi_{c}(y)\right]-E_{p(y | \theta)}\left[\phi_{c}(y)\right]<br>$$</p>
<ul>
<li> $E_{p_{e m p}}\left[\phi_{c}(y)\right]=\frac{1}{N} \sum_{n=1}^{N} \phi_{c}\left(y_{i}\right)$ : Expected feature vector according to empirical distribution.</li>
<li>$E_{p(y | \theta)}\left[\phi_{c}(y)\right]$ : Expected feature vector according to <u>model’s distribution.</u></li>
</ul>
<p>At optimum, gradient =0, i.e. $E_{p(y | \theta)}\left[\phi_{c}(y)\right]=\sum_{y} \phi_{c}(y) p(y | \theta)$. But this equation cannot solve for unknown $\theta$.</p>
</li>
<li><p><strong>Solution</strong>: Gradient-based optimizers.</p>
</li>
<li><p>$$<br>\frac{\partial l}{\partial \theta_{c}}=E_{p_{e m p}}\left[\phi_{c}(y)\right]-E_{p(y | \theta)}\left[\phi_{c}(y)\right]<br>$$</p>
<p>But, when computing $E_{p(y | \theta)}\left[\phi_{c}(y)\right]$ requires sum over all states of $y$ , which is <u>intractable</u>.</p>
</li>
<li><p><strong>Solution:</strong> combine <u>approximate inference</u> with <u>gradient-based learning</u>. i.e. <strong>Stochastic Maximum Likelihood</strong></p>
</li>
</ul>
</li>
<li><p><strong>Stochastic Maximum Likelihood:</strong></p>
<p><u>iteratively update</u>s the parameter $\theta_{k+1}$ at the $k$ step using the parameter and gradient from previous step:<br>$$<br>\theta_{k+1} \leftarrow \theta_{k}-\eta g_{k}<br>$$<br>where $\eta$ is step size or learning rate, $g_k\approx \frac{\part l}{\part \theta_C}$ is the gradient that can be approximated with <u><em>Markov Chain Monte Carlo (MCMC), sampling.</em></u></p>
<img src="https://ws1.sinaimg.cn/large/006tNc79gy1g22b3j4or3j31p00u07wh.jpg" style="zoom:30%"></li>
<li><p><strong>Maximum A posterior (MAP):</strong> </p>
<ul>
<li><p>add prior:</p>
</li>
<li><p>$$<br>\underset{\theta}{\operatorname{argmax}}\left{\sum_{i} \log p\left(y_{i} | \theta\right)+\log \underbrace{p(\theta)}_{\text{prior}}\right}<br>$$</p>
<p>Choose prior with hyper-parameters.</p>
</li>
</ul>
</li>
</ul>
<h2 id="Conditional-Random-Fields-CRF"><a href="#Conditional-Random-Fields-CRF" class="headerlink" title="Conditional Random Fields (CRF)"></a>Conditional Random Fields (CRF)</h2><p>CRF or discriminative random field</p>
<ul>
<li><p>a version of MRF where <u>all the clique potentials are conditioned on input feature</u> $X$:</p>
</li>
<li><p>$$<br>p(\mathbf{y} | \mathbf{x}, \mathbf{w})=\frac{1}{Z(\mathbf{x}, \mathbf{w})} \prod_{c} \psi_{c}\left(\mathbf{y}_{c} | \mathbf{x}, \mathbf{w}\right)<br>$$</p>
<ul>
<li><p><u>Log-linear representation of potentials:</u> </p>
</li>
<li><p>$$<br>\psi_{c}\left(\mathbf{y}<em>{c} | \mathbf{x}, \mathbf{w}\right)=\exp \left(\mathbf{w}</em>{c}^{T} \boldsymbol{\phi}\left(\mathbf{x}, \mathbf{y}_{c}\right)\right)<br>$$</p>
<p>where $\phi(\mathbb{x}, y_C)$ is a feature vector derived from the global inputs $X$ and the local set of labels $Y_C$.</p>
</li>
</ul>
<img src="https://ws1.sinaimg.cn/large/006tNc79gy1g22bmtv4dqj31kc0u04q6.jpg" style="zoom:30%"></li>
<li><p>Advantages: (compare to generative models)</p>
<ul>
<li>No need to waste resources, i.e. modelling things that we can always observe.<ul>
<li>Focus our attention on modeling what we care about, i.e. the distribution of labels given the data. </li>
</ul>
</li>
<li>We can make the potentials (or factors) of the model be data-dependent. <ul>
<li>e.g., in natural language processing problems, we can make the latent labels depend on global properties of the sentence, such as which language it is written in. </li>
</ul>
</li>
</ul>
</li>
<li><p>Disadvantages:</p>
<ul>
<li>require labeled training data</li>
<li>learning is slower.</li>
</ul>
</li>
<li><p>Parameter learning:</p>
<p>Consider CRF in log-linear form:<br>$$<br>p(\mathbf{y} | \mathbf{x}, \mathbf{w})=\frac{1}{Z(\mathbf{x}, \mathbf{w})} \prod_{c} \exp \left(\mathbf{w}<em>{c}^{T} \phi</em>{c}\left(\mathbf{x}, \mathbf{y}<em>{c}\right)\right)<br>$$<br>where $\phi</em>{c}\left(\mathrm{x}, y_{c}\right)$ is a feature vector derived from the global inputs $\mathbb{x}$ and the local set of labels $y_c$.</p>
<p>Scaled log-likelihood:<br>$$<br>\begin{aligned} \ell(\mathbf{w}) &amp; \triangleq \frac{1}{N} \sum_{i}^{N} \log p\left(\mathbf{y}<em>{i} | \mathbf{x}</em>{i}, \mathbf{w}\right) =\frac{1}{N} \sum_{i}^{N}\left[\sum_{c} \mathbf{w}<em>{c}^{T} \boldsymbol{\phi}</em>{c}\left(\mathbf{y}<em>{i}, \mathbf{x}</em>{i}\right)-\log Z\left(\mathbf{w}, \mathbf{x}<em>{i}\right)\right] \end{aligned}<br>$$<br>Gradient:<br>$$<br>\frac{\partial \ell}{\partial \mathbf{w}</em>{c}} =\frac{1}{N} \sum_{i}^{N}\left[\boldsymbol{\phi}<em>{c}\left(\mathbf{y}</em>{i}, \mathbf{x}<em>{i}\right)-\frac{\partial}{\partial \mathbf{w}</em>{c}} \log Z\left(\mathbf{w}, \mathbf{x}<em>{i}\right)\right] =\frac{1}{N} \sum</em>{i}^{N}\left[\boldsymbol{\phi}<em>{c}\left(\mathbf{y}</em>{i}, \mathbf{x}<em>{i}\right)-\mathbb{E}\left[\boldsymbol{\phi}</em>{c}\left(\mathbf{y}, \mathbf{x}<em>{i}\right)\right]\right]<br>$$<br>​                                                    Need labeled pairs of data $(y_i,x_i)</em>{i=1}^N$ for learning. And $\mathbb{E}\left[\boldsymbol{\phi}<em>{c}\left(\mathbf{y}, \mathbf{x}</em>{i}\right)\right] =\sum_{\mathbb{y}, \mathbb{x}<em>{i}} p\left(\mathbb{y} | \mathbb{x}</em>{i}, \mathbb{w}\right) \boldsymbol{\phi}<em>{c}\left(\mathbb{y}, \mathbb{x}</em>{i}\right)$</p>
<ul>
<li>depend on inputs $\mathbb{x}_i$</li>
<li>Need <em>inference</em> for every single training case inside each gradient step, which is $O(N)$ times slower than MRF.</li>
<li>Also use MAP to estimate unknown parameter $\underset{w}{\operatorname{argmax}}\left{\sum \log p\left(y_{i} | x_{i}, w\right)+\log p(w)\right}$ by choosing a prior.</li>
</ul>
</li>
</ul>
<h2 id="Probabilistic-inference"><a href="#Probabilistic-inference" class="headerlink" title="Probabilistic inference"></a>Probabilistic inference</h2><p>calculate $p(X_F|X_E)$ for arbitrary subset $E$ and $F$</p>
<hr>
<p><font color=#0099ff size=3 face="黑体">黑体 </font></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhang-xiaoxue.github.io/2020/04/30/Reinforcement%20Learning/3_RL_algorithms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/photo_blue.jpg">
      <meta itemprop="name" content="Xiaoxue Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiaoxue Zhang - NUS">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/30/Reinforcement%20Learning/3_RL_algorithms/" class="post-title-link" itemprop="url">3. RL algorithms</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-04-30 12:00:00" itemprop="dateCreated datePublished" datetime="2020-04-30T12:00:00+08:00">2020-04-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-08-16 15:39:44" itemprop="dateModified" datetime="2021-08-16T15:39:44+08:00">2021-08-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Reinforcement-Learning/" itemprop="url" rel="index"><span itemprop="name">Reinforcement Learning</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gpwcji8mrwj31790ndjus.jpg" width="700">

<h1 id="DQN-and-variants"><a href="#DQN-and-variants" class="headerlink" title="DQN and variants"></a>DQN and variants</h1><h2 id="DQN"><a href="#DQN" class="headerlink" title="DQN"></a>DQN</h2><p>Value: (state, reward, state_new)</p>
<p>$Q(s,a)$ 与当前得到的reward 和 $Q(s’,a)$有关。</p>
<p>价值函数近似：</p>
<p>$Q(s,a)=f(s,a)$, here, $f$ can be represented by NN. –&gt; $Q(s,a)=f(s,a,w)$ where $w$ is hte parameter of NN.</p>
<p>How to get the state_new? we trial and error –&gt; have state_new from previous experiences.</p>
<p>流程；</p>
<p>首先环境会给出一个obs，智能体根据值函数网络得到关于这个obs的所有Q(s,a)，然后利用$ϵ$−greedy选择action并做出决策，环境接收到此action后会给出一个奖励Rew及下一个obs。这是一个step。此时我们根据Rew去更新值函数网络的参数。接着进入下一个step。如此循环下去，直到我们训练出了一个好的值函数网络。</p>
<p>Q value的更新依靠$Q_{target}$:（利用reward和Q计算出来的目标Q value）, $R_{t+1}+\gamma\max_a Q(s_{t+1},a)$.</p>
<p>所以，我们把$Q_{target}$作为标签，使$Q$趋近于$Q_{target}$. </p>
<p>所以，loss function is $\ell(w)=\mathbb{E}[\underbrace{r+\gamma\max_{a’}Q(s’,a’,w) }<em>{Q</em>{target}}- Q(s,a,w)]$.</p>
<p>具体流程：</p>
<p>每次只要传入一组（s,a,r,s’），即当前所处状态s，当前选择的动作a，做出动作a后获得的奖励r，以及做出动作a后转移到的下一状态s’。这四个值都可以在模拟一局游戏时取到，而且每模拟一局游戏能取到非常多组数据。在论文中作者提出了经验回放（experience replay）的采集数据方法，即事先采样足够多组的数据放入一个固定容量的经验池中，然后每次训练时从该经验池中随机取出一个batch的数据进行梯度下降更新参数。值得注意的是这一个batch的数据训练完成后是放回经验池的，也就是说下次训练时是可以复用的。只有当产生新的数据时，才会更新经验池。当一轮训练完成，更新完模型参数后，再根据该模型提供的策略进行模拟游戏，产生新的数据并放入经验池中，由于该经验池是有最大容量的，所以最早的一些数据会被新的数据替代。像这样每玩几局游戏训练一次（玩游戏的同时其实是在更新训练数据），极大地提升了训练的效率。此外，为了更加稳定地训练模型，作者提出了固定target值的思想，具体做法是复制一个和原本Q网络一模一样的target-Q网络用于计算target值，使得target-Q网络的参数在一定时间段内保持固定不变，在这段时间内用梯度下降训练Q网络。然后阶段性地根据Q网络学习完后的参数更新这个target-Q网络（就是把Q网络的参数再复制过去）。</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpnxbqekppj31960ncgsj.jpg" style="zoom:40">

<blockquote>
<p>Q-Learning的target是 $R_{t+1}+γ\max_{a′}Q(S_{t+1},a′)$。它使用 $ϵ$−greedy策略来生成action $a_{t+1}$，但用来计算target的action却不一定是$a_{t+1}$，而是使得$Q(S_{t+1},a)$最大的action。这种产生行为的策略和进行评估的策略不一样的方法称为Off-policy方法。对于Q-Learning来说，产生行为的策略是$$ϵ$$−greedy，而进行评估的策略是greedy。$Q(s,a)\leftarrow Q(s,a)+\alpha(R+\gamma\max_{a’}Q(s’,a’)-Q(s,a))$</p>
<p>SarSa中使用$ϵ$−greedy策略生成action $a_{t+1}$，随即又用 $a_{t+1}$处对应的值函数来计算target，更新上一步的值函数。这种学习方式又称为On-policy。$Q(s,a)\leftarrow Q(s,a)+\alpha(R+\gamma Q(s’,a’)-Q(s,a))$</p>
</blockquote>
<h2 id="Double-DQN"><a href="#Double-DQN" class="headerlink" title="Double DQN"></a>Double DQN</h2><p>DDQN的模型结构基本和DQN的模型结构一模一样，唯一不同的就是它们的目标函数。<br>$$<br>Q^{DQN}<em>{target}(s,a) = R</em>{t+1} + \gamma \max_aQ(s’,a;\hat\theta)\<br>Q^{DoubleDQN}<em>{target}(s,a) = R</em>{t+1} + \gamma Q(s’, \operatorname{argmax}_a Q(s’,a;\theta),\hat\theta)<br>$$<br>这两个target函数的区别在于DoubleDQN的最优动作选择是根据当前正在更新的Q网络的参数 $\theta_t$，而DQN中的最优动作选择是根据target-Q网络的参数$\hat\theta_t$。这样做的原因是传统的DQN通常会高估Q值的大小（overestimation）。</p>
<p>而DDQN由于每次选择的根据是当前Q网络的参数，并不是像DQN那样根据target-Q的参数，所以当计算target值时是会比原来小一点的。（因为计算target值时要通过target-Q网络，在DQN中原本是根据target-Q的参数选择其中Q值最大的action，而现在用DDQN更换了选择以后计算出的Q值一定是小于或等于原来的Q值的）这样在一定程度上降低了overestimation，使得Q值更加接近真实值。</p>
<h2 id="Dueling-DQN"><a href="#Dueling-DQN" class="headerlink" title="Dueling DQN"></a>Dueling DQN</h2><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo4jju4nej30y60u0e47.jpg" width="500">

<p>把Q function拆分为state function和advantage function ：$Q(s,a;\theta, \alpha, \beta) = V(s;\theta, \beta)+A(s,a;\theta,\alpha)$, 式中，$V(s;\theta, \beta)$是state function，输出一个标量，$A(s,a;\theta,\alpha)$是advantage function，输出一个矢量，矢量长度等于动作空间大小； $\theta$指网络卷积层的参数； $\alpha$和$\beta$分别是2个分支的全连接层的参数<br>$$<br>V^\pi(s) = \mathbb E_{a\sim\pi(s)}[Q^\pi(s,a)] \<br>A^\pi(s,a) = Q^\pi(s,a) - V^\pi(s)<br>$$<br>V代表了在当前状态s下，Q值的平均期望（综合考虑了所有可选动作）。A代表了在选择动作a时Q值超出期望值的多少。两者相加就是实际的Q(s,a)。所以这样设计模型就是为了让神经网络对给定的s有一个基本的判断，在这个基础上再根据不同的action进行修正。但是按照上述想法直接训练是有问题的，问题就在于若神经网络把V训练成固定值0后，就相当于普通的DQN网络了，因为此时的A值就是Q值。所以我们需要给我们的神经网络加一个约束条件，让所有动作对应的A值之和为零，使得训练出的V值是所有n个Q值的平均值（n代表可选择的动作个数）。<br>$$<br>Q(s,a;\theta, \alpha, \beta) = V(s;\theta, \beta)+ (A(s,a;\theta,\alpha) - \frac{1}{|\mathcal A|} \sum_{a’}A(s,a’;\theta,\alpha)<br>$$<br>式中，里括号中的部分其实就是之前说的A值，公式里的$|\mathcal A|$代表了可选择动作的个数。可以明显看出若把|A|个动作对应的括号中的部分相加，它们的和为零。所以问题就转化为利用神经网络求上述公式中的V(s; \theta,\beta)与A(s,a; \theta, \alpha)。其中V(s; θ \theta θ, β \beta β)就是前文所提到的V值，而A(s,a; θ \theta θ, α \alpha α)和前文所提到的广义上的A值其实不一样，但可以通过A(s,a; θ \theta θ, α \alpha α)计算出A值。</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo8o0h1hgj31600sy7ae.jpg" width="550">

<ul>
<li>Double DQN：目的是减少因为max Q值计算带来的计算偏差，或者称为过度估计（over estimation）问题，用当前的Q网络来选择动作，用目标Q网络来计算目标Q。</li>
<li>Prioritised replay：也就是优先经验的意思。优先级采用目标Q值与当前Q值的差值来表示。优先级高，那么采样的概率就高。</li>
<li>Dueling Network：将Q网络分成两个通道，一个输出V，一个输出A，最后再合起来得到Qr。</li>
</ul>
<h1 id="Policy-based-method"><a href="#Policy-based-method" class="headerlink" title="Policy-based method"></a>Policy-based method</h1><h2 id="Policy-gradient"><a href="#Policy-gradient" class="headerlink" title="Policy gradient"></a>Policy gradient</h2><h3 id="一个角度来看"><a href="#一个角度来看" class="headerlink" title="一个角度来看"></a>一个角度来看</h3><ol>
<li><p>State-value function: $V_\pi(s_t) = \mathbb E_A [Q_\pi(s_t, A)] = \sum_a \pi(a|s_t) Q_\pi(s_t,a)$</p>
<p>通过state-value function的定义引出用策略网络来近似策略函数</p>
<p>Approximate the state-value function：</p>
<ul>
<li>Approximate policy function $\pi(a|s_t)$ by policy network $\pi(a|s_t;\theta)$.</li>
<li>Approximate value function $V_\pi(s_t)$ by $V_\pi(s_t) = \sum_a \pi(a|s_t;\theta) Q_\pi(s_t,a)$.</li>
</ul>
</li>
<li><p>用评价函数$L(\theta)$来评价策略的好坏，进而用策略梯度进行求解</p>
<p>learn $\theta$ that maximizes $L(\theta)=\mathbb E_S[V(S;\theta)]$</p>
<p>How to improve $\theta$?</p>
<ol>
<li><p>observe state $s$.</p>
</li>
<li><p>update policy by $\theta \leftarrow \theta + \beta \underbrace{ \frac{\partial V(s;\theta)}{\partial \theta}}<em>{policy\ gradient}$.<br>$$<br>\begin{array}{rCl}<br>\frac{\partial V(s;\theta)}{\partial \theta}<br>&amp;=&amp; \frac{\partial \sum_a \pi(a|s;\theta) Q_\pi(s,a)}{\partial \theta} \<br>&amp;=&amp; \sum_a \frac{\partial  \pi(a|s;\theta) Q_\pi(s,a)}{\partial \theta} \<br>&amp;=&amp; \sum_a \frac{\partial  \pi(a|s;\theta) }{\partial \theta} Q_\pi(s,a) \quad \text{assume $Q</em>{\pi}$ is independent of $\theta$} \<br>&amp;=&amp; \sum_a \pi(a|s;\theta) ; \frac{\partial  \log \pi(a|s;\theta) }{\partial \theta} Q_\pi(s,a) \<br>&amp;=&amp; \mathbb E_{A\sim\pi(\cdot|s,\theta)} \left[ \frac{\partial  \log \pi(a|s;\theta) }{\partial \theta} Q_\pi(s,a) \right]<br>\end{array}<br>$$<br>Thus, we have two forms of policy gradient:<br>$$<br>\begin{array}{rCl}<br>\text{Form 1: } &amp;\quad&amp;  \frac{\partial V(s;\theta)}{\partial \theta} = \sum_a \frac{\partial  \pi(a|s;\theta) }{\partial \theta} Q_\pi(s,a) \<br>\text{Form 2: } &amp;\quad&amp;  \frac{\partial V(s;\theta)}{\partial \theta} = \mathbb E_{A\sim\pi(\cdot|s,\theta)} \left[ \frac{\partial  \log \pi(a|s;\theta) }{\partial \theta} Q_\pi(s,a) \right]<br>\end{array}<br>$$</p>
</li>
</ol>
<ul>
<li><p>Case 1 (discrete actions) –&gt; Form 1</p>
<ol>
<li><p>Calculate $f(a,\theta) = \frac{\partial  \pi(a|s;\theta) }{\partial \theta} Q_\pi(s,a)$ for every acton $a\in \mathcal A$.</p>
</li>
<li><p>Policy gradient: $\frac{\partial V(s;\theta)}{\partial \theta} = \sum_a f(a,\theta)$</p>
<blockquote>
<p>if $|\mathcal A|$  is vast, this approach is costly.</p>
</blockquote>
</li>
</ol>
</li>
<li><p>Case 2 (continuous actions) –&gt; Form 2 </p>
<p>在求连续动作时，需要求定积分，这很难。一般采用Monte-Carlo近似的方法求出期望函数的无偏估计。（对于离散动作，这种方法也适用）。</p>
<ol>
<li>Randomly sample an action $\hat a$ according to the PDF $\pi(\cdot|s;\theta)$</li>
<li>Calculate $g(\hat a, \theta) = \frac{\partial  \log \pi(\hat a|s;\theta) }{\partial \theta} Q_\pi(s, \hat a)$</li>
<li>Use $g(\hat a, \theta)$ as an approximation to the policy gradient $\frac{\partial V(s;\theta)}{\partial \theta}$.</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>Algorithm:</p>
<img src="https://raw.githubusercontent.com/Lisnol1/CloudIMG/master/20210421160047.png" width="500"></li>
<li><p>Pros and Cons:</p>
<ul>
<li>Advantages:<ul>
<li>efficient in high-dimensional or continuous action spaces (output actions probability)</li>
<li>can learn stochastic policies</li>
<li>better convergence properties</li>
</ul>
</li>
<li>Disadvantages:<ul>
<li>typocally converge to a local rather global optimum</li>
<li>evaluating a policy is typically inefficient and high variance</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>遗留的问题： How to calculate $q_t$???</p>
<h4 id="Method-1-Reinforce"><a href="#Method-1-Reinforce" class="headerlink" title="Method 1: Reinforce"></a>Method 1: Reinforce</h4><ol>
<li>Play the game to the end and generate the trajectry &lt;$s_1, a_1, r_1, s_2, a_2, r_2, \cdots, S_T, a_T, r_T$&gt;</li>
<li>Compute the discounted return $G_t = \sum_{k=t}^T \gamma^{k-t} r_k$ for all $t$.</li>
<li>Since $Q_\pi(s_t,a_t) = \mathbb E[G_t]$, we can use $u_t$ to approximate $Q_\pi(s_t,a_t)$.</li>
<li>–&gt; $q_t = u_t$.</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Lisnol1/CloudIMG/master/20210421152427.png" width="500"> <img src="https://raw.githubusercontent.com/Lisnol1/CloudIMG/master/20210421152326.png" width='450'></p>
<h4 id="Method-2-Actor-Critic"><a href="#Method-2-Actor-Critic" class="headerlink" title="Method 2: Actor-Critic"></a>Method 2: Actor-Critic</h4><ul>
<li>approximate $Q_\pi$ using a neural network.</li>
</ul>
<h3 id="另一个角度来看"><a href="#另一个角度来看" class="headerlink" title="另一个角度来看"></a><strong>另一个角度来看</strong></h3><p>Loss: $L(\theta) = \mathbb E(r1 + \gamma r2 + \gamma^2r_3 + \cdots  | \pi(,\theta))$ , 所有带衰减reward的累计期望</p>
<p>如何能够计算出损失函数关于参数的梯度（也就是策略梯度）$\nabla_\theta L(\theta)$:</p>
<ul>
<li>对于一个策略网络，输入state，输出action的概率。然后execute action, 得到reward。</li>
<li>如果某一个动作得到reward多，使其出现的概率增大，如果某一个动作得到的reward少，使其出现的概率减小。</li>
<li>如果能够构造一个好的动作评判指标，来判断一个动作的好与坏，那么我们就可以通过改变动作的出现概率来优化策略！</li>
</ul>
<p>–&gt; 使用log likelihood $\log \pi(a|s,\theta)$, 且给定critic metric是$f(s,a)$. </p>
<p>–&gt; Loss：$L(\theta) = \sum \log \pi(a|s,\theta) f(s,a)$</p>
<p><strong>Parametrise</strong> the policy: $\pi_\theta(s,a)=\mathbb P \left[a|s,\theta\right]$.<br>$$<br>\nabla_\theta \pi_\theta(s,a) = \pi_\theta(s,a) \frac{\nabla_\theta \pi_\theta(s,a)}{\pi_\theta(s,a)} = \underbrace{\pi_\theta(s,a)}<em>{policy} \underbrace{\nabla_\theta \log \pi_\theta(s,a)}</em>{score\ function}<br>$$</p>
<ul>
<li>softmax policy: [discrete action space]<ul>
<li>weighting actions using linear combination of features $\phi(s,a)^\top\theta$</li>
<li>probability of action is proportional to exponentiated weight $\pi_\theta(s,a) \propto e^{\phi(s,a)^\top \theta}$</li>
<li>The score function is $\nabla_\theta \log \pi_\theta(s,a) = \phi(s,a) - \mathbb E_{\pi_\theta} [\phi(s,\cdot)]$</li>
</ul>
</li>
<li>Gaussian policy: [continuous action space]<ul>
<li>mean is linear combination of state feature $\mu(s) = \phi(s)^\top \theta$</li>
<li>variance is fixed $\sigma^2$ or parameterised</li>
<li>policy is Gaussian $a\sim\mathcal N(\mu(s),\sigma^2)$</li>
<li>the score function is $\nabla_\theta \log \pi_\theta(s,a) = \frac{(a-\mu(s))\phi(s)}{\sigma^2}$</li>
</ul>
</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li><p>require full episodes</p>
</li>
<li><p>high gradients variance. $\nabla L \simeq \mathbb E [Q(s,a) \nabla \log \pi(a|s)]$ which is proportional to the discounted reward from the given state.</p>
<p>–&gt; add baseline from $Q$, which can be :</p>
<ul>
<li>some constant value (mean of the discounted rewards)</li>
<li>moving average of discouted rewards</li>
<li>the value of the state $V(s)$</li>
</ul>
</li>
<li><p>Exploration. entropy 表征uncertainty。</p>
<p>为避免local optimum，substract entropy from the loss function and punish the entropy to be too certain.</p>
</li>
<li><p>Correlation between samples.</p>
</li>
</ol>
<h1 id="Actor-critic-and-Variants"><a href="#Actor-critic-and-Variants" class="headerlink" title="Actor-critic and Variants"></a>Actor-critic and Variants</h1><h2 id="Actor-critic"><a href="#Actor-critic" class="headerlink" title="Actor-critic"></a>Actor-critic</h2><ul>
<li><p>reduce the variance of the gradient (由于很难infinite交互，期望与真实有差异，会带来较大的variance)</p>
<p>actor-critic用一个独立模型估计轨迹的长期return，而不是直接使用轨迹的真实return。（类似于基于模型的Q-Learning 算法，在估计时使用模型估计轨迹价值，在更新时利用轨迹的回报得到目标价值，然后将模型的估计值和目标值进行比较，从而改进模型。）</p>
<p>$\nabla_\theta L(\theta) = \frac{1}{N} \sum_{i=1}^N\sum_{t=0}^T \left[\nabla_\theta \log \pi_\theta (a_{i,t}|s_{i,t}) \left(\sum_{t’=t}^{T}r(s_{i,t’},a_{i,t’}) - b_i \right)\right]$</p>
<p>方案：</p>
<ol>
<li>使用策略梯度法: $\sum_{t’=t}^{T}r(s_{i,t’},a_{i,t’}) - b_i$</li>
<li>使用状态值函数估计轨迹的return: $q(s,a)$</li>
<li>使用优势函数估计轨迹的return: $A(s,a) = q(s,a) - V(s)$</li>
<li>使用TD-Error估计轨迹的return: $r(s,a) + q(s) - q(s’)$ [只需要算一个价值函数V，V函数和动作无关，可以用来计算Q和A]</li>
</ol>
</li>
<li><p>Evaluation for value function</p>
<ul>
<li>Monte Carlo （用整条轨迹计算）<ul>
<li>$V^\pi(s_t) \approx \sum_{t’=t}^T r(s_{t’}, a_{t’})$</li>
<li>Training data: $\left{ \left(s_{i,t}, \underbrace{\sum_{t’=t}^T r(s_{t’}, a_{t’})}<em>{y</em>{i,t}}\right) \right}$</li>
<li>Loss: $L = \frac{1}{2} \sum_i | \hat V^\pi(s_i) - y_i |^2$</li>
</ul>
</li>
<li>TD （bootstrap):<ul>
<li>Training data: $\left{ \left(s_{i,t}, \underbrace{ r(s_{i,t}, a_{i,t})+ \hat V^\pi_\phi (s_{i,t+1})}<em>{y</em>{i,t}}\right) \right}$</li>
<li>引入了适当的bias， –&gt; 减小variance</li>
</ul>
</li>
</ul>
</li>
<li><p>Actor Critic Design Decisions</p>
<ul>
<li>用两个网络分别去拟合Actor网络和Critic网络<ul>
<li>优势是容易训练且稳定；缺点是没有共享feature，导致参数量增大，计算量也增大</li>
</ul>
</li>
<li>用同一个网络去拟合：<ul>
<li>解决了两个网络的优势，但是有可能会出现两个部分冲突的问题</li>
</ul>
</li>
</ul>
</li>
<li><p>Actor-Critic方法和Policy Gradient方法各有优劣：Actor-Critic方法方差小但是有偏，Policy-Gradient无偏但是方差大：</p>
<ul>
<li><p>Actor-critic: $\nabla_\theta L(\theta) = \frac{1}{N} \sum_{i=1}^N\sum_{t=0}^T \left[\nabla_\theta \log \pi_\theta (a_{i,t}|s_{i,t}) \left(r(s_{i,t},a_{i,t}) + \gamma\hat V^\pi_\phi(s_{i,t+1}) - \hat V^\pi_\phi(s_{i,t}) - b_i \right)\right]$</p>
<p>lower variance with bias</p>
</li>
<li><p>Policy graddient: $\nabla_\theta L(\theta) = \frac{1}{N} \sum_{i=1}^N\sum_{t=0}^T \left[\nabla_\theta \log \pi_\theta (a_{i,t}|s_{i,t}) \left(\sum_{t’=t}^{T}\gamma^{t’-t}r(s_{i,t’},a_{i,t’}) - b_i \right)\right]$</p>
<p>no bias with higher variace (because use single sample estimate)</p>
</li>
</ul>
</li>
<li><p>So, 结合两种方法，–&gt; no bias with low variance (because baseline is close to reward)<br>$$<br>\nabla_\theta L(\theta) = \frac{1}{N} \sum_{i=1}^N\sum_{t=0}^T \left[\nabla_\theta \log \pi_\theta (a_{i,t}|s_{i,t}) \left(\sum_{t’=t}^{T} \gamma^{t’-t}r(s_{i,t’},a_{i,t’}) - \hat V_\phi^\pi(s_{i,t}) \right)\right]<br>$$<br>如果用整条轨迹，或者仅仅一个step，都有缺点 –&gt; 折中一下 –&gt; n-step<br>$$<br>\nabla_\theta L(\theta) = \frac{1}{N} \sum_{i=1}^N\sum_{t=0}^T \left[\nabla_\theta \log \pi_\theta (a_{i,t}|s_{i,t}) \left(\sum_{t’=t}^{t+n} \gamma^{t’-t}r(s_{i,t’},a_{i,t’}) - \hat V_\phi^\pi(s_{i,t}) + \gamma^n \hat V_\phi^\pi(s_{i,t+n})\right)\right]<br>$$</p>
</li>
</ul>
<blockquote>
<p>随着AC的run，networks变得越来越确定optimum value，sigma变得越来越小，越来越倾向于exploiting，而不是exploring</p>
</blockquote>
<h2 id="A2C"><a href="#A2C" class="headerlink" title="A2C"></a>A2C</h2><h2 id="A3C"><a href="#A3C" class="headerlink" title="A3C"></a>A3C</h2><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gpwcfcvd52j30nm0cl76q.jpg" width="500">

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gpwchx6pyoj315g0u0wlx.jpg" width="500">

<p>Parallel actor-learners have a stabilizing effect on training allowing many methods (DQN, n-step Sarsa, AC) to successfully train NN.</p>
<p>与memory replay不同，A3C允许多个agents独立play on separate environments. Each environment is in CPU.</p>
<p>global optimizer and global actor-critic. each agent interact environments in separate thread. Agents reach terminal state –&gt; gradient descent on global optimizer </p>
<p>Pseudocode:</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gpwcprru9jj30vm0ky432.jpg" width="800">

<p>具体实现：</p>
<p>使用torch的multiprocessing模块来生成多个trainer进程，每个进程里都会有一个player与环境交互并采集样本，定期利用buffer中的数据进行梯度更新。为了保证异步更新的有效性，在main进程里实例化了一个share model (global_actor_critic)，并且通过global的optimizer来对异步收集的梯度进行优化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">global_actor_critic = Agent(input_dims=input_dims, n_actions=n_actions, gamma=GAMMA) <span class="comment"># global network</span></span><br><span class="line">global_actor_critic.actor_critic.share_memory() <span class="comment"># share the global parameters in multiprocessing</span></span><br><span class="line">optimizer = SharedAdam(global_actor_critic.actor_critic.parameters(), lr=lr, betas=(<span class="number">0.92</span>,<span class="number">0.999</span>)) <span class="comment"># global optimizer</span></span><br></pre></td></tr></table></figure>

<p>在每个train进程中，每个agent需要定期地和global_actor_critic进行同步，从而保证整体优化的方向一致。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.local_actor_critic.actor_critic.load_state_dict(self.global_actor_critic.actor_critic.state_dict())</span><br></pre></td></tr></table></figure>

<p>因此，我们可以得到train进程使用的是需要优化的目标策略，并且该模型是被所有进程所共享的，在global optimizer中可以实现share model （global_actor_critic）的更新。但是，在train进程中，每个agent的model是单独实例化的，因此并不和share model共享内存空间，只是会定期地通过load_state_dict()来获取共享模型的参数。player和环境交互采样得到的trajectory用于计算policy loss和value loss，通过backward获得model的梯度。然而这些梯度都是train进程player model上的，并不在share model中，所以必须要有某个机制来进行同步。因此，可以以下方法实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> local_param, global_param <span class="keyword">in</span> <span class="built_in">zip</span>(self.local_actor_critic.actor_critic.parameters(), self.global_actor_critic.actor_critic.parameters()):</span><br><span class="line">    global_param._grad = local_param.grad</span><br></pre></td></tr></table></figure>

<p>注意，这里的=赋值是一个浅拷贝，因此是共享地址的，也就是share model的参数的梯度和player model参数的梯度共享一个内存空间，那么自然梯度就完成了同步。</p>
<h1 id="Actor-Critic-based-methods"><a href="#Actor-Critic-based-methods" class="headerlink" title="Actor-Critic based methods"></a>Actor-Critic based methods</h1><h2 id="TRPO"><a href="#TRPO" class="headerlink" title="TRPO"></a>TRPO</h2><p>Property：</p>
<ul>
<li>On-policy</li>
<li> can be used for environments with either discrete or continuous action spaces.</li>
<li>supports parallelization </li>
</ul>
<p>policy update: $\theta = \theta_{old} + \alpha \nabla_\theta J$. </p>
<blockquote>
<p>更新步长$\alpha$非常重要，当步长不合适时，更新的参数所对应的策略是一个更不好的策略，当利用这个更不好的策略进行采样学习时，再次更新的参数会更差，因此很容易导致越学越差，最后崩溃。选择合适的步长$\alpha$使得新的回报函数的值单调递增。</p>
<p>回报函数： $\eta(\tilde\pi)=E_{\tau \mid \tilde\pi}\left[\sum_{t=0}^{\infty} \gamma^{t}\left(r\left(s_{t}\right)\right)\right]$.</p>
<p>如果可以将新的策略所对应的回报函数$\eta(\tilde\pi)$分解成旧的策略所对应的回报函数$$\eta(\pi)$$+其他项。只要新的策略所对应的其他项大于等于零，那么新的策略就能保证回报函数单调不减。</p>
</blockquote>
<p>$$<br>\eta(\tilde\pi)=\eta(\pi)+E_{s_{0}, a_{0}, \cdots \sim\eta(\tilde\pi)}\left[\sum_{t=0}^{\infty} \gamma^{t} A_{\pi}\left(s_{t}, a_{t}\right)\right]<br>$$</p>
<p>其中，$\tilde\pi$ 和 $\pi$ 分别表示新策略和旧策略，$\begin{array}{c}<br>A_{\pi}(s, a)=Q_{\pi}(s, a)-V_{\pi}(s)<br>=E_{s^{\prime} \sim P\left(s^{\prime} \mid s, a\right)}\left[r(s)+\gamma V^{\pi}\left(s^{\prime}\right)-V^{\pi}(s)\right]<br>\end{array}$.</p>
<blockquote>
<p>Proof:<br>$$<br>\begin{array}{rcl}<br>&amp;&amp; E_{\tau \mid \tilde{\pi}}\left[\sum\limits_{t=0}^{\infty} \gamma^{t} A_{\pi}\left(s_{t}, a_{t}\right)\right] \<br>&amp;=&amp; E_{\tau \mid \tilde{\pi}}\left[\sum\limits_{t=0}^{\infty} \gamma^{t}\left(r(s)+\gamma V^{\pi}\left(s_{t+1}\right)-V^{\pi}\left(s_{t}\right)\right)\right] \<br>&amp;=&amp; E_{\tau \mid \tilde{\pi}}\left[\sum\limits_{t=0}^{\infty} \gamma^{t}\left(r\left(s_{t}\right)\right)+\sum\limits_{t=0}^{\infty} \gamma^{t}\left(\gamma V^{\pi}\left(s_{t+1}\right)-V^{\pi}\left(s_{t}\right)\right)\right] \<br>&amp;=&amp; E_{\tau \mid \tilde{\pi}}\left[\sum\limits_{t=0}^{\infty} \gamma^{t}\left(r\left(s_{t}\right)\right)\right]+E_{s_{0}}\left[-V^{\pi}\left(s_{0}\right)\right] \<br>&amp;=&amp;\eta(\tilde{\pi})-\eta(\pi)<br>\end{array}<br>$$</p>
</blockquote>
<p>因此，可以转化为<br>$$<br>\begin{array}{rCl}<br>\eta(\tilde{\pi}) &amp;=&amp;<br>\eta(\pi)+\sum\limits_{t=0}^{\infty} \sum\limits_{s} P\left(s_{t}=s \mid \tilde{\pi}\right)\sum\limits_{a} \tilde{\pi}(a \mid s) \gamma^{t} A_{\pi}(s, a) \<br>&amp;=&amp; \eta(\pi)+\sum\limits_{s} \rho_{\tilde{\pi}}(s) \sum\limits_{a} \tilde{\pi}(a \mid s) A^{\pi}(s, a)<br>\end{array}<br>$$<br>其中，$\rho_{\pi}(s)=P\left(s_{0}=s\right)+\gamma P\left(s_{1}=s\right)+\gamma^{2} P\left(s_{2}=s\right)+\cdots$表示discounted visitation frequencies。 此时状态$s$的分布对新策略$\tilde\pi$严重依赖。</p>
<p><strong>用旧策略$\pi$的状态分布来代替新策略$\tilde\pi$的状态分布</strong>，surrogate loss function is<br>$$<br>\begin{array}{rCl}<br>L_\pi(\tilde{\pi})<br>&amp;=&amp; \eta(\pi)+\sum\limits_{s} \rho_(s) \sum\limits_{a} \tilde{\pi}(a \mid s) A^{\pi}(s, a)<br>\end{array}<br>$$<br>此时，产生动作$a$是基于新的策略$\tilde\pi$，但新策略$\tilde\pi$的参数$\theta$是未知的，无法应用。</p>
<p><strong>利用重要性采样对动作分布进行处理:</strong><br>$$<br>\sum_{a} \tilde{\pi}<em>{\theta}\left(a \mid s</em>{n}\right) A_{\theta_{\text {old}}}\left(s_{n}, a\right)=E_{a \sim q}\left[\frac{\tilde{\pi}<em>{\theta}\left(a \mid s</em>{n}\right)}{q\left(a \mid s_{n}\right)} A_{\theta_{\text{old}}}\left(s_{n}, a\right)\right]<br>$$<br>surrogate loss function变为：<br>$$<br>\sum_{a} \tilde{\pi}<em>{\theta}\left(a \mid s</em>{n}\right) A_{\theta_{\text {old}}}\left(s_{n}, a\right)=E_{a \sim q}\left[\frac{\tilde{\pi}<em>{\theta}\left(a \mid s</em>{n}\right)}{q\left(a \mid s_{n}\right)} A_{\theta_{\text{old}}}\left(s_{n}, a\right)\right]<br>$$<br>比较该surrogate loss function $L_\pi(\tilde\pi)$ 和 $\eta(\tilde\pi)$:<br>$$<br>\begin{aligned}<br>L_{\pi_{\theta_{o l d}}}\left(\pi_{\theta_{o l d}}\right) &amp;=\eta\left(\pi_{\theta_{o l d}}\right) \<br>\left.\nabla_{\theta} L_{\pi_{\theta_{o l d}}}\left(\pi_{\theta}\right)\right|<em>{\theta=\theta</em>{o l d}} &amp;=\left.\nabla_{\theta} \eta\left(\pi_{\theta}\right)\right|<em>{\theta=\theta</em>{o l d}}<br>\end{aligned}<br>$$<br><img src="https://raw.githubusercontent.com/Lisnol1/CloudIMG/master/20210427143013.png" width="400"></p>
<p><strong>利用不等式：</strong>$\eta(\tilde{\pi})  \geq L_{\pi}(\tilde{\pi})-C D_{\mathrm{KL}}^{\max }(\pi, \tilde{\pi})$, where $C=\frac{4 \epsilon \gamma}{(1-\gamma)^{2}}$. </p>
<blockquote>
<p>该不等式给出了$\eta(\tilde\pi)$的lower bound $M_i(\pi) = L_{\pi_i}(\pi) - CD_{KL}^{\max}(\pi_i, \pi)$</p>
<p>证明策略的单调性：</p>
<p>$\eta\left(\pi_{i+1}\right) \geqslant M_{i}\left(\pi_{i+1}\right)$, 且 $\eta\left(\pi_{i}\right) = M_{i}\left(\pi_{i}\right)$, 则 $\eta\left(\pi_{i+1}\right)-\eta\left(\pi_{i}\right) \geqslant M_{i}\left(\pi_{i+1}\right)-M\left(\pi_{i}\right)$.</p>
<p>如果新策略能够使得$M_i$最大，我们可以得到$M_i(\pi_{i+1}) - M(\pi_i) \geq 0$, 则 $\eta(\pi_{i+1})-\eta(\pi_i) \geq 0$.</p>
</blockquote>
<p>使得$M_i$最大的策略 $\iff$ $\underset{\theta}{\operatorname{maximize}}\left[L_{\theta_{\text {old }}}(\theta)-C D_{\mathrm{KL}}^{\max }\left(\theta_{\text {old }}, \theta\right)\right]$</p>
<p><strong>利用惩罚因子$C$,</strong> the step size will be small. –&gt; add constraint on the KL divergence (trust region constraint):<br>$$<br>\begin{array}{l}<br>\underset{\theta}{\operatorname{maximize}} \quad \mathbb{E}<em>{s \sim \rho</em>{\theta_{\text {old}}}, a \sim \pi_{\theta_{old}}}\left[\frac{\pi_{\theta}(a \mid s)}{\pi_{\theta_{old}}(a \mid s)} A_{\theta_{\text {old}}}(s, a)\right] \<br>\text {subject to} \quad D^{\max}<em>{\mathrm{KL}}\left(\theta</em>{\text {old}}, {\theta}\right) \leq \delta<br>\end{array}<br>$$<br><strong>在约束条件中，利用平均KL散度代替最大KL散度。</strong>该问题化简为<br>$$<br>\begin{array}{l}<br>\underset{\theta}{\operatorname{maximize}} \quad \mathbb{E}<em>{s \sim \rho</em>{\theta_{\text {old }}}, a \sim q}\left[\frac{\pi_{\theta}(a \mid s)}{q(a \mid s)} Q_{\theta_{\text {old }}}(s, a)\right] \<br>\text { subject to} \quad \mathbb{E}<em>{s \sim \rho</em>{\theta_{\text {old}}}}\left[D_{\mathrm{KL}}\left(\pi_{\theta_{\text {old}}}(\cdot \mid s) | \pi_{\theta}(\cdot \mid s)\right)\right] \leq \delta<br>\end{array}<br>$$<br>The objective function (surrogate advantage) is a measure of how policy $\pi_\theta$ performs relative to the old policy $\pi_{\theta_{old}}$ using data from the old policy.</p>
<p>接下来就是利用采样得到数据，然后求样本均值，解决优化问题即可。至此，TRPO理论算法完成。</p>
<p><strong>求解优化问题：</strong></p>
<p>The objective and constraint are both zero when $\theta=\theta_{old}$. Furthermore, the gradient of the constraint with respect to $\theta$ is zero when $\theta=\theta_{old}$. TRPO makes some approximations to get an answer quickly. We Taylor expand the objective and constraint to leading order around $\theta_{old}$:<br>$$<br>\begin{array}{c}<br>\mathcal{L}\left(\theta_{k}, \theta\right) \approx g^{T}\left(\theta-\theta_{k}\right) \<br>\bar{D}<em>{K L}\left(\theta | \theta</em>{k}\right) \approx \frac{1}{2}\left(\theta-\theta_{k}\right)^{T} H\left(\theta-\theta_{k}\right)<br>\end{array}<br>$$<br>resulting in an approximate optimization problem,<br>$$<br>\begin{array}{r}<br>\theta_{k+1}=\arg \max <em>{\theta} g^{T}\left(\theta-\theta</em>{k}\right) \<br>\text { s.t. } \frac{1}{2}\left(\theta-\theta_{k}\right)^{T} H\left(\theta-\theta_{k}\right) \leq \delta<br>\end{array}<br>$$<br>This approximate problem can be analytically solved by the methods of Lagrangian duality, yielding the solution:<br>$$<br>\theta_{k+1}=\theta_{k}+\sqrt{\frac{2 \delta}{g^{T} H^{-1} g}} H^{-1} g<br>$$<br>A problem is that, due to the approximation errors introduced by the Taylor expansion, this may not satisfy the KL constraint, or actually improve the surrogate advantage. TRPO adds a modification to this update rule: a backtracking line search,<br>$$<br>\theta_{k+1}=\theta_{k}+\alpha^{j} \sqrt{\frac{2 \delta}{g^{T} H^{-1} g}} H^{-1} g<br>$$<br>where $\alpha\in (0,1)$ is the backtracking coefficient, and $j$ is the smallest nonnegative integer such that $\pi_\theta$ satisfies the KL constraint and produces a positive surrogate advantage.</p>
<p>Lastly: computing and storing the matrix inverse, $H^{-1}$, is painfully expensive when dealing with neural network policies with thousands or millions of parameters. TRPO sidesteps the issue by using the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Conjugate_gradient_method">conjugate gradient</a> algorithm to solve $Hx=g$ for $x=H^{-1}g$ , requiring only a function which can compute the matrix-vector product $Hx$  instead of computing and storing the whole matrix $H$ directly. This is not too hard to do: we set up a symbolic operation to calculate<br>$$<br>H x=\nabla_{\theta}\left(\left(\nabla_{\theta} \bar{D}<em>{K L}\left(\theta | \theta</em>{k}\right)\right)^{T} x\right)<br>$$<br>which gives us the correct output without computing the whole matrix.</p>
<p>Over the course of training, the policy typically becomes progressively less random, as the update rule encourages it to exploit rewards that it has already found. This may cause the policy to get trapped in local optima. </p>
<img src="https://raw.githubusercontent.com/Lisnol1/CloudIMG/master/20210427124447.png" width="600">

<h2 id="PPO"><a href="#PPO" class="headerlink" title="PPO"></a>PPO</h2><p>Fundamental Knowledge:</p>
<ol>
<li><p>TRPO:<br>$$<br>\begin{array}{ll}<br>\underset{\theta}{\operatorname{maximize}} &amp; \hat{\mathbb{E}}<em>{t}\left[\frac{\pi</em>{\theta}\left(a_{t} \mid s_{t}\right)}{\pi_{\theta_{\text {old }}}\left(a_{t} \mid s_{t}\right)} \hat{A}<em>{t}\right] \<br>\text { subject to } &amp; \widehat{\mathbb{E}}</em>{t}\left[\operatorname{KL}\left[\pi_{\theta_{\text {old }}}\left(\cdot \mid s_{t}\right), \pi_{\theta}\left(\cdot \mid s_{t}\right)\right]\right] \leq \delta<br>\end{array}<br>$$<br>This problem can efficiently be approximately solved using the conjugate gradient algorithm, after making a linear approximation to the objective and a quadratic approximation to the constraint. The theory justifying TRPO actually suggests using a penalty instead of a constraint, i.e., solving the unconstrained optimization problem<br>$$<br>\underset{\theta}{\operatorname{maximize}} \hat{\mathbb{E}}<em>{t}\left[\frac{\pi</em>{\theta}\left(a_{t} \mid s_{t}\right)}{\pi_{\theta_{\text {old }}}\left(a_{t} \mid s_{t}\right)} \hat{A}<em>{t}-\beta \operatorname{KL}\left[\pi</em>{\theta_{\text {old }}}\left(\cdot \mid s_{t}\right), \pi_{\theta}\left(\cdot \mid s_{t}\right)\right]\right]<br>$$</p>
<p>for some coefficient $\beta$. </p>
<blockquote>
<p>a certain surrogate objective (which computes the max KL over states instead of the mean) forms a lower bound (i.e., a pessimistic bound) on the performance of the policy $\pi$.</p>
</blockquote>
<p>TRPO uses a hard constraint rather than a penalty because it is hard to choose a single value of $\beta$ that performs well across different problems—or even within a single problem, where the the characteristics change over the course of learning.</p>
</li>
<li><p>Actor-critic:</p>
<p>sensitive to perturbations (small change in parameters of network –&gt; big change of policy space)</p>
</li>
</ol>
<p>In order to address this issue, PPO:</p>
<ul>
<li>limits update to policy network, and <ul>
<li>base the update on the ratio of new policy to old. (make the ratio be confined into a range –&gt; not take big step in parameter space)</li>
</ul>
</li>
<li>Need to account for goodness of state (advantage)</li>
<li>clip the loss function and take lower bound with minimum function</li>
<li>Track a fixed length trajectory of memories (instead of many transitions)</li>
<li>Use multiple network updates per data sample. Use minibatch stochastic gradient ascent</li>
<li>can use multiple parallel CPU</li>
</ul>
<p><strong>Important Components:</strong></p>
<ul>
<li><p>Update Actor is different<br>$$<br>L^{CPI}(\theta) = \hat{\mathbb E} \left[ \frac{\pi_\theta(a_t|s_t)}{\pi_{\theta_{old}}(a_t|s_t) }\hat A_t \right] = \hat{\mathbb E} \left[r_t(\theta) \hat A_t \right]<br>$$</p>
<ul>
<li>based on ratio of new policy to old policy (can use log)</li>
<li>consider the advantage</li>
</ul>
</li>
<li><p>Only maximize $L^{CPI}(\theta)$ will lead to large policy update, –&gt; Modify objective </p>
<p>Adding epsilon (about 0.2) for clip/min operations<br>$$<br>L^{CPI}(\theta) = \hat{\mathbb E} \left[ \min\left(r_t(\theta)\hat{A}_t;, ; \operatorname{clip}(r_t(\theta), 1-\epsilon, 1+\epsilon) \right)\hat{A}_t \right]<br>$$</p>
</li>
<li><p>pessimistic lower bound to the loss</p>
<ul>
<li>smaller loss, smaller gradient, smaller update</li>
</ul>
</li>
<li><p>Advantages at each time step:<br>$$<br>\hat{A}<em>t = \delta_t + (\gamma\lambda)\delta</em>{t+1} + \cdots +(\gamma\lambda)^{T-t+1}\delta_{T-1}<br>$$<br>where $\delta_t = r_t + \gamma V(s_{t+1}) - V(s_t)$.</p>
<ul>
<li>show the benefit of the new state over the old state</li>
<li>$\lambda$ is a smoothing parameter (about 0.95) to help to reduce variance</li>
<li>Nested for loops</li>
</ul>
</li>
<li><p>Critic loss is straightforward </p>
<ul>
<li>Return = advantage + critic_value (from memory)</li>
<li>$L_{critic}$ = MSE( return - critic_value ) [from network]</li>
</ul>
</li>
<li><p>Total loss is sum of clipped actor and critic<br>$$<br>L_t^{CLIP+VF+S} = \hat{\mathbb E} \left[ L_t^{CLIP}(\theta) - c_1 L_t^{VF} + c_2 S<a href="s_t">\pi_\theta</a> \right]<br>$$</p>
<ul>
<li>coefficient $c_1$ of the critic</li>
<li>$S$ term is the entropy term [which is required if the actor and critic are coupled].</li>
</ul>
</li>
</ul>
<p>总结：</p>
<p>PPO: off-policy </p>
<ul>
<li><p>通过importance sampling实现离线更新策略（可以使用行为策略所得到的数据用来更新目标策略）</p>
<p>使用$\theta_{old}$采样的数据，训练$\theta$这个actor，过程中$\theta_{old}$是fixed的所以可以重复使用用$\theta_{old}$的数据训练$\theta$许多次，增加数据利用率，提高训练速度。也就是说，在importance sampling中，我们使用$\theta_{old}$获得数据，来估计$\theta$的期望分布。、</p>
</li>
<li><p>但是注意，此时两种策略的分布不能差别很大。–&gt; 引入了约束条件。</p>
<ul>
<li>TRPO是加入了KL($\theta_{old},\theta$) divergence的constraint</li>
<li>PPO是在目标函数后加入了关于$\beta$KL($\theta_{old},\theta$)的惩罚项.</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/Lisnol1/CloudIMG/master/20210428163711.png" width="500">

<h2 id="DDPG"><a href="#DDPG" class="headerlink" title="DDPG"></a>DDPG</h2><p>同样，也是Actor-Critic架构。</p>
<ul>
<li><p>Actor:</p>
<ul>
<li>Input: state $s$</li>
<li>Output: action $a$。 【在Actor-Critic方法中，输出的是一个概率分布】</li>
<li>更新方法是基于梯度上升的。</li>
<li>该网络的损失函数就是从critic网络中获取的Q值的平均值，在实现的过程中，需要加入负号，即最小化损失函数，来与深度学习框架保持一致。用数学公式表示其损失函数就是：$L_{actor}=\mathbb E \left[{Q(s,a|\theta^Q)}|_{s=s_t,a=\mu(s_t|\theta^\mu)} \right]$.</li>
</ul>
</li>
<li><p>Critic：</p>
<ul>
<li>Input: state $s$ and action $a$</li>
<li>Output: Q value $Q(s,a)$。 【在Actor-Critic方法中，输出的是$V(s)$】</li>
<li>通过最小化目标网络与现有网络之间的均方误差来更新现有网络的参数，</li>
</ul>
</li>
<li><p>加入experience replay buffer，存储agent与env之间的交互数据。</p>
</li>
<li><p>在实际操作中，如果更新目标在变化，会导致更新困难。–&gt; use “soft” target updates, rather than directly copy the weights –&gt; 方法：添加target actor 和 target critic 网络。并在更新target 网络参数时增加权重$\tau$，即每一步仅采用相对小的权重采用相应训练中的network更新；如此的目的在于尽可能保障训练能够收敛；</p>
</li>
<li><p>Exploration via random process, 为actor采取的action基础上增加一定的随机扰动, 以保障一定的探索完整动作空间的几率。一般的, 相应随机扰动的幅度随着训练的深入而逐步递减；</p>
</li>
<li><p>Batch normalization, 为每层神经网络之前加入batch normalization层, 可以降低不对状态量取值范围差异对模型稳定性的影响程度。</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/Lisnol1/CloudIMG/master/20210428145330.png" width="700">



<h2 id="TD3"><a href="#TD3" class="headerlink" title="TD3"></a>TD3</h2><p>DDPG起源于DQN，是DQN解决连续控制问题的一个解决方法。而DQN有一个众所周知的问题，就是Q值会被高估。这是因为我们用$\operatorname{argmax}Q(s’)$去代替$V(s’)$，去评估$Q(s)$。当我们每一步都这样做的时候，很容易就会出现高估$Q$值的情况。类似地，DDPG也会有这个问题。可以借鉴double DQN的思路来解决这个问题。在TD3中，可以用两套网络估算$Q$值，相对较小的那个作为我们更新的目标。这就是TD3的基本思路。</p>
<blockquote>
<p>DDPG算法涉及了4个网络，TD3需要用到6个网络。</p>
</blockquote>
<img src="https://pic4.zhimg.com/v2-4908c65bdca28a7602a864add9777d4f_r.jpg" width="550">

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0tivv1upj30tf0hi771.jpg" width="550">

<ul>
<li><p>Actor:</p>
<p>与DDPG相同</p>
</li>
<li><p>Critic:</p>
<ul>
<li>两个target ciritc网络，用于计算两个Q值：$Q_1(A’)$和$Q_2(A’)$.</li>
<li>$\min(Q_1(A’), Q_2(A’))$用来计算target value，i.e. $y_i = r+ \gamma \min(Q_1(A’), Q_2(A’))$. 而计算出的target value也是两个critic网络的更新目标。</li>
<li>两个critic 网络的意义：虽然更新目标一样，两个网络会越来越趋近与和实际q值相同。但由于网络参数的初始值不一样，会导致计算出来的值有所不同。所以我们可以选择较小的值去估算q值，避免q值被高估。</li>
</ul>
</li>
<li><p>送</p>
</li>
</ul>
<h1 id="SAC"><a href="#SAC" class="headerlink" title="SAC"></a>SAC</h1><h2 id="Maximum-Entropy-RL"><a href="#Maximum-Entropy-RL" class="headerlink" title="Maximum Entropy RL"></a>Maximum Entropy RL</h2><p>之前的RL算法中，学习目标主要是学习一个policy使得累积reward的期望值最大：$\pi^{*}=\arg \max <em>{\pi} \mathbb{E}</em>{\left(s_{t}, a_{t}\right) \sim \rho_{\pi}}\left[\sum_{t} R\left(s_{t}, a_{t}\right)\right]$.</p>
<p>而最大熵RL的学习目标，除了学习一个policy使得累积reward最大，还要求policy的每一次输出的action的entropy最大：<br>$$<br>\pi^{*}=\arg \max <em>{\pi} \mathbb{E}</em>{\left(s_{t}, a_{t}\right) \sim \rho_{\pi}} \left[\sum_{t} \underbrace{R\left(s_{t}, a_{t}\right)}<em>{\text {reward }}+\alpha \underbrace{H\left(\pi\left(\cdot \mid s</em>{t}\right)\right)}_{\text {entropy }}\right]<br>$$<br>$\alpha$是temperature parameter决定entropy项和reward之间的relative importance。通过增加entropy项，可使得策略随机化，即输出的每一个action的概率尽可能均匀，而不是集中在一个action上。从而鼓励exploration，也可以学到更多near-optimal行为（也就是在一些状态下， 可能存在多个action都是最优的，那么使得选择它们的概率相同，可以提高学习速度）。</p>
<blockquote>
<p>在信息论中，熵（entropy）是接收的每条消息中包含的信息的平均量，又被稱為信息熵、信源熵、平均自信息量。这里，“消息”代表来自分布或数据流中的事件、样本或特征。（熵最好理解为不确定性的量度而不是确定性的量度，因为越随机的信源的熵越大。）来自信源的另一个特征是样本的概率分布。这里的想法是，比较不可能发生的事情，当它发生了，会提供更多的信息。由于一些其他的原因，把信息（熵）定义为概率分布的对数的相反数是有道理的。事件的概率分布和每个事件的信息量构成了一个随机变量，这个随机变量的均值（即期望）就是这个分布产生的信息量的平均值（即熵）。</p>
</blockquote>
<h2 id="Soft-Policy-Iteration"><a href="#Soft-Policy-Iteration" class="headerlink" title="Soft Policy Iteration"></a>Soft Policy Iteration</h2><h3 id="Soft-policy-evaluation"><a href="#Soft-policy-evaluation" class="headerlink" title="Soft policy evaluation"></a>Soft policy evaluation</h3><p>思路1（通过DP得到Soft bellman equation）：</p>
<ul>
<li>因此可以得到Soft Bellman Backup equation (Entropy项额外乘上$\alpha$系数) :<br>$$<br>q_{\pi}(s, a)=r(s, a)+\gamma \sum_{s^{\prime} \in \mathcal{S}} \mathcal{P}<em>{s s^{\prime}}^{a} \sum</em>{a^{\prime} \in \mathcal{A}} \pi\left(a^{\prime} \mid s^{\prime}\right)\left(q_{\pi}\left(s^{\prime}, a^{\prime}\right)-\alpha \log \left(\pi\left(a^{\prime} \mid s^{\prime}\right)\right)\right.<br>$$<br>可以得到Soft Bellman Backup的 更新公式:<br>$$<br>Q_{\text{soft}}\left(s_{t}, a_{t}\right)=r\left(s_{t}, a_{t}\right)+\gamma \mathbb{E}<em>{s</em>{t+1}, a_{t+1}}\left[Q_{\text{soft}}\left(s_{t+1}, a_{t+1}\right)-\alpha \log \left(\pi\left(a_{t+1} \mid s_{t+1}\right)\right)\right]<br>$$</li>
</ul>
<p>思路2（将entropy嵌入reward）：</p>
<ul>
<li>Reward with entropy:<br>$$<br>r_{\text{soft}}\left(s_{t}, a_{t}\right)=r\left(s_{t}, a_{t}\right)+\gamma \alpha \mathbb{E}<em>{s</em>{t+1} \sim \rho} H\left(\pi\left(\cdot \mid s_{t+1}\right)\right)<br>$$<br>将该reward代入Bellman equation $Q\left(s_{t}, a_{t}\right)=r\left(s_{t}, a_{t}\right)+\gamma \mathbb{E}<em>{s</em>{t+1}, a_{t+1}}\left[Q\left(s_{t+1}, a_{t+1}\right)\right]$, 得到<br>$$<br>\begin{array}{rCl}<br>Q_{\text{soft}}\left(s_{t}, a_{t}\right) &amp;=&amp; r\left(s_{t}, a_{t}\right)+ \gamma \alpha \mathbb{E}<em>{s</em>{t+1} \sim \rho} H\left(\pi\left(\cdot \mid s_{t+1}\right)\right) + \gamma \mathbb{E}<em>{s</em>{t+1}, a_{t+1}}\left[Q_{\text{soft}}\left(s_{t+1}, a_{t+1}\right)\right] \<br>&amp;=&amp; r\left(s_{t}, a_{t}\right)+ \gamma \mathbb{E}<em>{s</em>{t+1}\sim\rho,a_{t+1}\sim\pi} \left[Q_{\text{soft}}\left(s_{t+1}, a_{t+1}\right)\right] + \gamma \alpha \mathbb{E}<em>{s</em>{t+1}\sim\rho} H\left(\pi\left(\cdot \mid s_{t+1}\right)\right) \<br>&amp;=&amp; r\left(s_{t}, a_{t}\right)+ \gamma \mathbb{E}<em>{s</em>{t+1}\sim\rho} \mathbb{E}<em>{a</em>{t+1}\sim\pi} \left[Q_{\text{soft}}\left(s_{t+1}, a_{t+1}\right)\right] - \gamma \alpha \mathbb{E}<em>{s</em>{t+1}\sim\rho}\mathbb{E}<em>{a</em>{t+1}\sim\pi} \log\pi(a_{t+1}|s_{t+1}) \<br>&amp;=&amp; r\left(s_{t}, a_{t}\right)+ \gamma \mathbb{E}<em>{s</em>{t+1}\sim\rho} \left[ \mathbb{E}<em>{a</em>{t+1}\sim\pi}\left[Q_{\text{soft}}\left(s_{t+1}, a_{t+1}\right) - \alpha \log\pi(a_{t+1}|s_{t+1}) \right]\right] \<br>&amp;=&amp; r\left(s_{t}, a_{t}\right)+ \gamma \mathbb{E}<em>{s</em>{t+1},a_{t+1}}\left[Q_{\text{soft}}\left(s_{t+1}, a_{t+1}\right) - \alpha \log\pi(a_{t+1}|s_{t+1}) \right] \<br>\end{array}<br>$$<br>该结果也和思路1得到的结果相同。</li>
</ul>
<p>因此，根据$Q\left(s_{t}, a_{t}\right)=r\left(s_{t}, a_{t}\right)+\gamma \mathbb{E}<em>{s</em>{t+1} \sim \rho}\left[V\left(s_{t+1}\right)\right]$，可得到$V_{\text{soft}}(s_t)$:<br>$$<br>V_{\text{soft}}\left(s_{t}\right)=\mathbb{E}<em>{a</em>{t} \sim \pi}\left[Q_{\text {soft}}\left(s_{t}, a_{t}\right)-\alpha \log \pi\left(a_{t} \mid s_{t}\right)\right]<br>$$</p>
<p><strong>Soft Policy Evaluation:</strong> 固定policy，使用soft Bellman equation更新Q value直到收敛<br>$$<br>Q_{\text{soft}}\left(s_{t}, a_{t}\right)=r\left(s_{t}, a_{t}\right)+\gamma \mathbb{E}<em>{s</em>{t+1}, a_{t+1}}\left[Q_{\text{soft}}\left(s_{t+1}, a_{t+1}\right)-\alpha \log \left(\pi\left(a_{t+1} \mid s_{t+1}\right)\right)\right]<br>$$</p>
<h3 id="Soft-policy-improvement"><a href="#Soft-policy-improvement" class="headerlink" title="Soft policy improvement"></a>Soft policy improvement</h3><p>stochastic policy的重要性：面对多模的（multimodal）的Q function，传统的RL只能收敛到一个选择（左图），而更优的办法是右图，让policy也直接符合Q的分布。</p>
<img src="https://raw.githubusercontent.com/Lisnol1/CloudIMG/master/20210430154648.png" width="600">

<p>这里，通过定义energy-based policy as：$\pi(a_t|s_t) \propto \exp(-\mathcal E(s_t,a_t))$。设定$\mathcal E(s_t,a_t)=-\frac{1}{\alpha}Q_{\text{soft}}(s_t,a_t)$, 可以得到$\pi(a_t|s_t) \propto \exp(-\mathcal E(s_t,a_t))$。根据$V_{\text{soft}}\left(s_{t}\right)=\mathbb{E}<em>{a</em>{t} \sim \pi}\left[Q_{\text {soft}}\left(s_{t}, a_{t}\right)-\alpha \log \pi\left(a_{t} \mid s_{t}\right)\right]$, 可以得到</p>
<p>$$<br>\begin{array}{rCl}<br>\pi(s_t,a_t) &amp;=&amp; \exp \left( \frac{1}{\alpha} \left(Q_{\text{soft}}(s_t,a_t) - V_{\text{soft}}(s_t) \right)\right) \<br>&amp;=&amp; \frac{\frac{1}{\alpha}Q_{\text{soft}}(s_t,a_t)}{\frac{1}{\alpha}V_{\text{soft}}(s_t)} \propto Q_{\text{soft}}(s_t,a_t)<br>\end{array}<br>$$<br>其中，$\exp \left(\frac{1}{\alpha} V_{\text {soft }}\left(s_{t}\right)\right)=\int \exp \left(\frac{1}{\alpha} Q_{\text {soft }}\left(s_{t}, a\right)\right) d a$，因此，$V_{\text {soft }}\left(s_{t}\right) \triangleq \alpha \log \int \exp \left(\frac{1}{\alpha} Q_{\text {soft }}\left(s_{t}, a\right)\right) d a$</p>
<p>所以，$\underset{a}{\operatorname{soft max}} f(a):=\log \int \exp f(a) d a$, –&gt; $Q_{\text {soft }}\left(s_{t}, a_{t}\right)=\mathbb{E}\left[r_{t}+\gamma \underset{a}{\operatorname{soft max}} Q\left(s_{t+1}, a\right)\right]$.</p>
<p>因此可以得到：$\pi_{\text{MaxEnt}}^{<em>}\left(a_{t} \mid s_{t}\right)=\exp \left(\frac{1}{\alpha}\left(Q_{\text {soft }}^{</em>}\left(s_{t}, a_{t}\right)-V_{\text {soft}}^{*}\left(s_{t}\right)\right)\right)$。</p>
<p><strong>Soft Policy Improvement</strong>: 更新policy towards the exponential of new Q-function. Restrict the policy to some set of policies, like Gaussian.<br>$$<br>\pi^{\prime}=\arg \min <em>{\pi</em>{k} \in \Pi} D_{K L}\left(\pi_{k}\left(\cdot \mid s_{t}\right) \Big| \frac{\exp \left(\frac{1}{\alpha} Q_{\text {soft }}^{\pi}\left(s_{t}, \cdot\right)\right)}{Z_{\text {soft }}^{\pi}\left(s_{t}\right)}\right)<br>$$<br>其中, $Z^\pi_{\text{soft}}(s_t)$ 就是是一个配分函数，用于归一化分布，在求导的时候可以直接忽略。此处，通过KL divergence来趋近$\exp(Q_{\text{soft}}^{\pi}(s_t,\cdot))$ ，从而限制policy在一定范围的policies $\Pi$中，从而变得tractable，policy的分布可以是高斯分布。</p>
<h2 id="Soft-Actor-Critic"><a href="#Soft-Actor-Critic" class="headerlink" title="Soft Actor Critic"></a>Soft Actor Critic</h2><p>旧版SAC：</p>
<img src="https://raw.githubusercontent.com/Lisnol1/CloudIMG/master/20210501150503.png" width="800">

<p>新版SAC：</p>
<img src="https://raw.githubusercontent.com/Lisnol1/CloudIMG/master/20210501151446.png" width="800">

<ul>
<li><p>Critic：<br>$$<br>\begin{aligned}<br>J_{Q}(\theta) &amp;=\mathbb{E}<em>{\left(s</em>{t}, a_{t}, s_{t+1}\right) \sim \mathcal{D}}\left[\frac{1}{2}\left(Q_{\theta}\left(s_{t}, a_{t}\right)-\left(r\left(s_{t}, a_{t}\right)+\gamma V_{\bar{\theta}}\left(s_{t+1}\right)\right)\right)^{2}\right] \<br>&amp;=\mathbb{E}<em>{\left(s</em>{t}, a_{t}, s_{t+1}\right) \sim \mathcal{D}, a_{t+1} \sim \pi_{\phi}}\left[\frac{1}{2}\left(Q_{\theta}\left(s_{t}, a_{t}\right)-\left(r\left(s_{t}, a_{t}\right)+\gamma\left(Q_{\bar{\theta}}\left(s_{t+1}, a_{t+1}\right)-\alpha \log \left(\pi_{\phi}\left(a_{t+1} \mid s_{t+1}\right)\right)\right)\right)\right)^{2}\right]<br>\end{aligned}<br>$$<br>这里和DDPG一样，构造了一个target soft Q 网络带参数$\bar \theta$，这个参数通过exponentially moving average Q网络的参数$\theta$得到。</p>
<p>在第一个版本的SAC中，他们单独定义了Value网络进行更新，</p>
<p>在新版的SAC中，由于自动更新temperature $\alpha$就直接使用Q网络更新。</p>
</li>
<li><p>Actor：<br>$$<br>\begin{aligned}<br>J_{\pi}(\phi) &amp;=D_{\mathrm{KL}}\left(\pi_{\phi}\left(. \mid s_{t}\right) | \exp \left(\frac{1}{\alpha} Q_{\theta}\left(s_{t}, .\right)-\log Z\left(s_{t}\right)\right)\right) \<br>&amp;=\mathbb{E}<em>{s</em>{t} \sim \mathcal{D}, a_{t} \sim \pi_{\phi}}\left[\log \left(\frac{\pi_{\phi}\left(a_{t} \mid s_{t}\right)}{\exp \left(\frac{1}{\alpha} Q_{\theta}\left(s_{t}, a_{t}\right)-\log Z\left(s_{t}\right)\right)}\right)\right] \<br>&amp;=\mathbb{E}<em>{s</em>{t} \sim \mathcal{D}, a_{t} \sim \pi_{\phi}}\left[\log \pi_{\phi}\left(a_{t} \mid s_{t}\right)-\frac{1}{\alpha} Q_{\theta}\left(s_{t}, a_{t}\right)+\log Z\left(s_{t}\right)\right]<br>\end{aligned}<br>$$<br>这里的action我们采用reparameterization trick来得到，即 $a_{t}=f_{\phi}\left(\varepsilon_{t} ; s_{t}\right)=f_{\phi}^{\mu}\left(s_{t}\right)+\varepsilon_{t} \odot f_{\phi}^{\sigma}\left(s_{t}\right)$。</p>
<p>$f$函数输出平均值和方差，然后$\epsilon$是noise，从标准正态分布采样。使用这个trick，整个过程就是完全可微的(loss 乘以$\alpha$并去掉不影响梯度的常量log partition function $Z(s_t)$：<br>$$<br>J_{\pi}(\phi)=\mathbb{E}<em>{s</em>{t} \sim \mathcal{D}, \varepsilon \sim \mathcal{N}}\left[\alpha \log \pi_{\phi}\left(f_{\phi}\left(\varepsilon_{t} ; s_{t}\right) \mid s_{t}\right)-Q_{\theta}\left(s_{t}, f_{\phi}\left(\varepsilon_{t} ; s_{t}\right)\right)\right]<br>$$</p>
</li>
<li><p>Update temperature</p>
<p>前面的SAC中，我们只是人为给定一个固定的temperature $\alpha$ 作为entropy的权重，但实际上由于reward的不断变化，采用固定的temperature并不合理，会让整个训练不稳定，因此，有必要能够自动调节这个temperature。当policy探索到新的区域时，最优的action还不清楚，应该调高temperature 去探索更多的空间。当某一个区域已经探索得差不多，最优的action基本确定了，那么这个temperature就可以减小。</p>
<p>这里，SAC的作者构造了一个带约束的优化问题，让平均的entropy权重是有限制的，但是在不同的state下entropy的权重是可变的，即 $\max <em>{\pi</em>{0}, \ldots, \pi_{T}} \mathbb{E}\left[\sum_{t=0}^{T} r\left(s_{t}, a_{t}\right)\right]$ s.t. $\forall t, \mathcal{H}\left(\pi_{t}\right) \geq \mathcal{H}_{0}$</p>
<p>最后得到temperature的loss：<br>$$<br>J(\alpha)=\mathbb{E}<em>{a</em>{t} \sim \pi_{t}}\left[-\alpha \log \pi_{t}\left(a_{t} \mid \pi_{t}\right)-\alpha \mathcal{H}_{0}\right]<br>$$</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/Lisnol1/CloudIMG/master/20210430180012.png" width="700">

<p>DDPG与SAC的区别：</p>
<blockquote>
<ul>
<li><p>DDPG训练得到的是一个deterministic policy确定性策略，也就是说这个策略对于一种状态state只考虑一个最优的动作。Deterministic policy的最终目标找到最优路径。</p>
</li>
<li><p>Stochastic policy随机策略在实际应用中往往是更好的做法。比如我们让机器人抓取一个水杯，机器人是有无数条路径去实现这个过程的，而并不是只有唯一的一种做法。因此，我们就需要DRL算法能够给出一个随机策略，在每一个state上都能输出每一种action的概率，比如有3个action都是最优的，概率一样都最大，那么我们就可以从这些action中随机选择一个做出action输出。<strong>最大熵maximum entropy的核心思想就是不遗落到任意一个有用的action，有用的trajectory</strong>。对比DDPG的deterministic policy的做法，看到一个好的就捡起来，差一点的就不要了，而最大熵是都要捡起来，都要考虑。</p>
<p>Stochastic policy要求熵最大，就意味着神经网络需要去explore探索所有可能的最优路径，优势如下：</p>
<ol>
<li>学到policy可以作为更复杂具体任务的初始化。因为通过最大熵，policy不仅仅学到一种解决任务的方法，而是所有all。因此这样的policy就更有利于去学习新的任务。比如我们一开始是学走，然后之后要学朝某一个特定方向走。</li>
<li>更强的exploration能力，这是显而易见的，能够更容易的在多模态reward （multimodal reward）下找到更好的模式。比如既要求机器人走的好，又要求机器人节约能源</li>
<li>更robust鲁棒，更强的generalization。因为要从不同的方式来探索各种最优的可能性，也因此面对干扰的时候能够更容易做出调整。（干扰会是学习过程中看到的一种state，既然已经探索到了，学到了就可以更好的做出反应，继续获取高reward）</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>基于最大熵的RL算法有什么优势？</strong></p>
<p>以前用deterministic policy的算法，我们找到了一条最优路径，学习过程也就结束了。现在，我们还要求熵最大，就意味着神经网络需要去explore探索所有可能的最优路径，这可以产生以下多种优势：</p>
<p>1）学到policy可以作为更复杂具体任务的初始化。因为通过最大熵，policy不仅仅学到一种解决任务的方法，而是所有all。因此这样的policy就更有利于去学习新的任务。比如我们一开始是学走，然后之后要学朝某一个特定方向走。</p>
<p>2）更强的exploration能力，这是显而易见的，能够更容易的在多模态reward （multimodal reward）下找到更好的模式。比如既要求机器人走的好，又要求机器人节约能源</p>
<p>3）更robust鲁棒，更强的generalization。因为要从不同的方式来探索各种最优的可能性，也因此面对干扰的时候能够更容易做出调整。（干扰会是神经网络学习过程中看到的一种state，既然已经探索到了，学到了就可以更好的做出反应，继续获取高reward）</p>
<h2 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h2><p>DRL中，特别是面向连续控制continuous control，主要的三类算法：</p>
<ul>
<li>TRPO,PPO</li>
<li>DDPG及其拓展（<a href="https://link.zhihu.com/?target=https://arxiv.org/abs/1804.08617">D4PG</a>,TD3等）</li>
<li>Soft Q-Learning, Soft Actor-Critic</li>
</ul>
<p>PPO算法是目前最主流的DRL算法，同时面向离散控制（discrete control）和连续控制（continuous control）。但是PPO是一种on-policy的算法，面临着严重的sample inefficiency，需要巨量的采样才能学习，因此在实际应用中较难实现。</p>
<p>DDPG及其拓展则是面向连续控制的off policy算法，相对PPO 更sample efficient。DDPG训练的是一种确定性策略deterministic policy，即每一个state下都只考虑最优的一个动作。</p>
<p>Soft Actor-Critic (SAC)是面向Maximum Entropy Reinforcement learning 开发的一种off policy算法，和DDPG相比，Soft Actor-Critic使用的是随机策略stochastic policy，相比确定性策略具有一定的优势。Soft Actor-Critic效果好，且能直接应用到真实机器人上。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhang-xiaoxue.github.io/2020/03/30/Reinforcement%20Learning/2.%20Bellman%20equation%20of%20optimality/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/photo_blue.jpg">
      <meta itemprop="name" content="Xiaoxue Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiaoxue Zhang - NUS">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/30/Reinforcement%20Learning/2.%20Bellman%20equation%20of%20optimality/" class="post-title-link" itemprop="url">2. Bellman Equation of Optimality</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-03-30 12:00:00" itemprop="dateCreated datePublished" datetime="2020-03-30T12:00:00+08:00">2020-03-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-08-16 15:39:29" itemprop="dateModified" datetime="2021-08-16T15:39:29+08:00">2021-08-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Reinforcement-Learning/" itemprop="url" rel="index"><span itemprop="name">Reinforcement Learning</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Tabular-Learning-and-the-Bellman-Equation"><a href="#Tabular-Learning-and-the-Bellman-Equation" class="headerlink" title="Tabular Learning and the Bellman Equation"></a>Tabular Learning and the Bellman Equation</h1><p>Value: expected total reward that is obtained from the state.<br>$$<br>V(s)=\mathbb E \left[ \sum_{t=0}^{\infty} r_t\gamma^t \right]<br>$$<br>where $r_t$ is the local reward obtained at time $t$ of the episode.</p>
<p>Then 可以选择action，based on values.</p>
<p>但是在一些复杂的环境下，‘exploration (探索)’ 是非常重要的，因为从长远来看greedy strategy不一定是好的。探索才能得到optimum并且avoid trap。</p>
<h1 id="1-Bellman-equation-of-optimality"><a href="#1-Bellman-equation-of-optimality" class="headerlink" title="1. Bellman equation of optimality"></a>1. Bellman equation of optimality</h1><p>Deterministic cases:</p>
<p>For an agent in state $s_0$, there are N actions to reach states $s_1, s_2, \cdots, s_N$ with rewards $r_1, r_2, \cdots, r_N$. Assume we know the value $V_1, V_2, \cdots, V_N$。 So, $V_0(a=a_i)=r_i+V_i$. </p>
<p>in order to choose the best action, agent needs to calculate the resulting values for every action and choose the maximum possible outcome. $V_0 = \max_{a\in {1, 2,\cdots, N}} (r_a+V_a)$. If we use discount factor $\gamma$, then it becomes $V_0 = \max_{a\in {1, 2,\cdots, N}} (r_a+\gamma V_a)$. So we look at the immediate reward + long-term value of the sate.</p>
<p>Stochastic cases:<br>$$<br>V_0 = \mathbb E_{s\sim S} \left[r_{s,a}+\gamma V_s\right] = \sum\limits_{s\in S} p_{a,0\rightarrow s} (r_{s,a}+\gamma V_s)<br>$$</p>
<p>For a general cases, the Bellman optimality equation is<br>$$<br>V_0 = \max_{a\in A} \mathbb E_{s\sim S} \left[r_{s,a}+\gamma V_s\right] = \max_{a\in A} \sum\limits_{s\in S} p_{a,0\rightarrow s} (r_{s,a}+\gamma V_s)<br>$$<br>where $p_{a,i\rightarrow j}$ is the probability of action a, from state $i$ to state $j$.</p>
<p>Meaning: the optimal value of the state is equal to the action, which gives us the maximum possible expected immediate reward, plus discounted long-term reward for the next state. This definition is recursive: the value of the state is defined via the values of immediate reachable states.</p>
<p>state的最优value等于最好action对应的value，也就是最大可能的期望即时reward加上乘以折扣因子的下个状态的长期reward。显然，这个定义是recursive的，这个状态的value是使用reachable下一个状态的value来计算的。</p>
<h1 id="2-Value-Iteration"><a href="#2-Value-Iteration" class="headerlink" title="2. Value Iteration"></a>2. Value Iteration</h1><h2 id="2-1-Value-of-action"><a href="#2-1-Value-of-action" class="headerlink" title="2.1 Value of action"></a>2.1 Value of action</h2><ul>
<li>Values of $Q$ for every pair of state and action:</li>
</ul>
<p>$$<br>Q_{s,a} = \mathbb E_{s’\sim S} \left[r_{s,a} + \gamma V_{s’}\right] = \sum_{s;’\in S} {p_{a,s\rightarrow s’}(r_{s,a}+\gamma V_{s’})}<br>$$</p>
<blockquote>
<p>$Q$ for the state $s$ and action $a$ equals the expected immediate reward and the discounted long-term reward of the destination state. </p>
</blockquote>
<ul>
<li>Value of state $V_s$: </li>
</ul>
<p>$$<br>V_s = \max_{a\in A} Q_{s,a}<br>$$</p>
<blockquote>
<p>The value of a state equals to the value of the maximum action we can execute from this state.</p>
</blockquote>
<p>Therefore, we can obtain<br>$$<br>Q_{s,a} = r_{s,a} + \gamma \max_{a’\in A}Q_{s’,a’}<br>$$</p>
<h2 id="2-2-Value-iteration-Q-learning-algorithm"><a href="#2-2-Value-iteration-Q-learning-algorithm" class="headerlink" title="2.2 Value iteration (Q-learning) algorithm"></a>2.2 Value iteration (Q-learning) algorithm</h2><p>Can numerically calculate the values of states and values of actions of MDPs with known transition probabilities and rewards. </p>
<p>Procedure for values of states:</p>
<ol>
<li>Initialize values of all states $V_i$ to some initial value (usually zero or random)</li>
<li>For every state $s$ in the MDP, perform the Bellman update $V_s \leftarrow \max_a \sum_{s’} p_{a,s\rightarrow s’} (r_{s,a}+\gamma V_{s’})$</li>
<li>Repeat step 2 for some large number of steps until changes become too small</li>
</ol>
<p>Procedure for values of actions:</p>
<ol>
<li>Initialize all $Q_{s,a}$ to zero </li>
<li>For every state $s$ and every action $a$ in this state, perform the update $Q_{s,a} \leftarrow \sum_{s’} p_{a,s\rightarrow s’} (r_{s,a}+\gamma \max_{a’} Q_{s’,a’})$</li>
<li>Repeat step 2 for some large number of steps until changes become too small</li>
</ol>
<p>Limitations:</p>
<ul>
<li>state space should be discrete and small to perform multiple iterations over all states. (possible solution: discretization)</li>
<li>rarely know the transition probability for the actions and reward matrix. In Bellman, we need both a reward for every transition and probability of this transition. (solution: use experience as an estimation for both unknowns.)</li>
</ul>
<h2 id="2-3-Practice"><a href="#2-3-Practice" class="headerlink" title="2.3 Practice"></a>2.3 Practice</h2><p>three tables:</p>
<ol>
<li>Reward table: dictionary <ul>
<li>key (state + action + target state)</li>
<li>value: immediate reward</li>
</ul>
</li>
<li>Transition table: dictionary to count the experienced transitions. <ul>
<li>Key: state + action, </li>
<li>value: another dictionary mapping the target state into a count of times that we have seen it. 看到target state的频数。</li>
<li>used to estimate the probabilities of transitions. 用来估测 transition probability</li>
</ul>
</li>
<li>Value table: dictionary mapping a state into the calculated value. </li>
</ol>
<p>Procedure:</p>
<ol>
<li>play random steps from the environment –&gt; populate the reward and transition tables.</li>
<li>perform a value iteration loop for all states, update value table</li>
<li>paly several full episodes to check the improvement using the updated value table. </li>
</ol>
<p>Code example of value iteration:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/PacktPublishing/Deep-Reinforcement-Learning-Hands-On/blob/master/Chapter05/01_frozenlake_v_iteration.py">https://github.com/PacktPublishing/Deep-Reinforcement-Learning-Hands-On/blob/master/Chapter05/01_frozenlake_v_iteration.py</a></p>
<p>Main functions in the code:</p>
<ol>
<li><p><code>play_n_random-steps(count)</code>: </p>
<ul>
<li>gather random experience from environment and update reward and transition tables</li>
</ul>
</li>
<li><p><code>calc_action_value(state, action)</code>:</p>
<ul>
<li>calculate the value of the action from the state, using transition, reward and value tables.</li>
<li>so, we can select the best action and calculate the new value of the state.</li>
</ul>
</li>
<li><p><code>select_action(state):</code></p>
</li>
<li><p><code>play_episode(env):</code></p>
</li>
<li><p><code>value_iteration():</code></p>
</li>
<li></li>
</ol>
<p>Code example of Q learning：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/PacktPublishing/Deep-Reinforcement-Learning-Hands-On/blob/master/Chapter05/02_frozenlake_q_iteration.py">https://github.com/PacktPublishing/Deep-Reinforcement-Learning-Hands-On/blob/master/Chapter05/02_frozenlake_q_iteration.py</a></p>
<p>Difference from the previous code of value iteration:</p>
<ol>
<li>Value table. In value iteration, we keep the value of state, so the key in the value table is a state. In Q-learning, Q-function has two parameters: state and action, so the key in the value table is (state, action)</li>
<li>In Q-learning, we do not need the <code>calc-action_value</code> function, since the action value is stored in the value table.</li>
<li><code>value_iteration</code>. In value iteration, </li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhang-xiaoxue.github.io/2020/03/01/Reinforcement%20Learning/1.%20Cross-Entropy%20method/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/photo_blue.jpg">
      <meta itemprop="name" content="Xiaoxue Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiaoxue Zhang - NUS">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/01/Reinforcement%20Learning/1.%20Cross-Entropy%20method/" class="post-title-link" itemprop="url">1. Cross-entropy method</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-03-01 12:00:00" itemprop="dateCreated datePublished" datetime="2020-03-01T12:00:00+08:00">2020-03-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-08-16 15:39:17" itemprop="dateModified" datetime="2021-08-16T15:39:17+08:00">2021-08-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Reinforcement-Learning/" itemprop="url" rel="index"><span itemprop="name">Reinforcement Learning</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>RL 方法分类：</p>
<ul>
<li>model-free v.s. model-based<ul>
<li>model-free: <ul>
<li>不需要build a model for 环境或者reward，直接连接observations到actions</li>
<li>适合deterministic environments，比如board game with strict rules.</li>
</ul>
</li>
<li>model-based：<ul>
<li>尝试predict下一步的next observation 或 reward， 并基于预测来学则可能最好的action. </li>
<li>easier to train, 当建模比较难的时候</li>
</ul>
</li>
</ul>
</li>
<li>value-based v.s. policy-based<ul>
<li>Policy-based:<ul>
<li>directly approximate the policy of the agent</li>
<li><u>policy is usually represented by probability distribution over available actions</u>. </li>
</ul>
</li>
<li>value-based:<ul>
<li>计算每个可能action的value，选择最好的action。  </li>
</ul>
</li>
</ul>
</li>
<li>on-policy v.s. off-policy<ul>
<li>off-policy: 能够学习old historical data (obtained by a previous version of the agent or recorded by human demonstration or just seen by the same agent several episodes ago)</li>
<li>on-policy: requires fresh data obtained from the environment</li>
</ul>
</li>
</ul>
<h1 id="1-Cross-Entropy-method"><a href="#1-Cross-Entropy-method" class="headerlink" title="1. Cross-Entropy method"></a>1. Cross-Entropy method</h1><ul>
<li><p>Property:</p>
<ul>
<li>Simple</li>
<li>Good convergence: works well in simple environments (不需要复杂多步policy，有short episodes with frequent rewards).</li>
<li>model-free</li>
<li>policy-based </li>
<li>on-policy</li>
</ul>
</li>
<li><p>Pipeline of the loop:</p>
<ul>
<li>pass the observation to the network –&gt; get probability distribution over actions –&gt; random sampling using the distribution –&gt; get action –&gt; obtain next observation </li>
</ul>
</li>
<li><p>Core of cross-entropy:</p>
<ul>
<li>舍弃不好的episodes，用好的episodes训练</li>
</ul>
</li>
<li><p>Steps：</p>
<ol>
<li>Play N episodes</li>
<li>calculate total reward for each episode, decide on a reward boundary (percentile, e.g., 60th)</li>
<li>throw away all episodes with a reward below the boundary</li>
<li>train on the remaining episodes</li>
<li>repeat</li>
</ol>
<p>Based on this procedure, neural network can learn how to repeat actions which leads to a larger reward. Then the boundary will be higher. </p>
</li>
</ul>
<h1 id="2-Cross-entropy-on-CartPole"><a href="#2-Cross-entropy-on-CartPole" class="headerlink" title="2. Cross-entropy on CartPole"></a>2. Cross-entropy on CartPole</h1><p>use one-hidden-layer neural network with <code>ReLU</code> and 128 hidden neurons. </p>
<p>code example：</p>
<p> <a target="_blank" rel="noopener" href="https://github.com/PacktPublishing/Deep-Reinforcement-Learning-Hands-On/blob/master/Chapter04/01_cartpole.py">https://github.com/PacktPublishing/Deep-Reinforcement-Learning-Hands-On/blob/master/Chapter04/01_cartpole.py</a></p>
<h1 id="3-Cross-entropy-on-FrozenLake"><a href="#3-Cross-entropy-on-FrozenLake" class="headerlink" title="3. Cross-entropy on  FrozenLake"></a>3. Cross-entropy on  FrozenLake</h1><p>grid world with specific rules</p>
<p>code example:</p>
<p>naïve cross-entropy, which may fail.</p>
<p><a target="_blank" rel="noopener" href="https://github.com/PacktPublishing/Deep-Reinforcement-Learning-Hands-On/blob/master/Chapter04/02_frozenlake_naive.py">https://github.com/PacktPublishing/Deep-Reinforcement-Learning-Hands-On/blob/master/Chapter04/02_frozenlake_naive.py</a></p>
<p>Shows the limitation of cross-entropy:</p>
<ul>
<li>no intermediate indication about whether the agent has succeeded or failed.</li>
<li>total reward of episodes should have enough variability to separate the good episodes from the bad ones.</li>
<li>for training, episodes have to be finite and short.</li>
</ul>
<p>tweaked code of cross-entropy:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/PacktPublishing/Deep-Reinforcement-Learning-Hands-On/blob/master/Chapter04/03_frozenlake_tweaked.py">https://github.com/PacktPublishing/Deep-Reinforcement-Learning-Hands-On/blob/master/Chapter04/03_frozenlake_tweaked.py</a></p>
<p>modification: 1) lager batches, 2) add discount factor, 3) keep good episodes for a longer time, 4) decrease learning rate, 5) much longer training time.</p>
<h1 id="4-Theoretical-background-of-cross-entropy"><a href="#4-Theoretical-background-of-cross-entropy" class="headerlink" title="4. Theoretical background of cross-entropy"></a>4. Theoretical background of cross-entropy</h1><p>basis of cross-entropy lies in the importance sampling theorem:<br>$$<br>\mathbb E_{x\sim p(x)} \left[H(x)\right] = \int_x p(x)H(x) dx = \int_x q(x)\frac{p(x)}{q(x)}H(x) dx = \mathbb E_{x\sim q(x)} \left[\frac{p(x)}{q(x)}H(x)\right]<br>$$<br>In RL, $H(x)$ is a reward value obtained by some policy $x$, and $p(x)$ is the distribution of all possible policies. </p>
<p>我们不想通过search所有可能的policy来maximizes我们的reward。我们希望可以找到一种方法来用$q(x)$来近似$p(x)H(x)$，通过迭代减小这两者之间的distance。</p>
<p>这两者的distance可以通过<strong>KL divergence</strong>来计算。KL divergence的表达式是<br>$$<br>KL(p_1(x) | p_2(x)) = \mathbb E_{x\sim p_1(x)} \left[\log\frac{p_1(x)}{p_2(x)}\right] = \underbrace{\mathbb E_{x\sim p_1(x)}\left[\log{p_1(x)}\right]}<em>{\text{entropy}}  - \underbrace{\mathbb E</em>{x\sim p_1(x)} \left[\log{p_2(x)}\right]}<em>{\text{corss-entropy}}<br>$$<br>结合两个公式，我们可以得到一个iterative algorithm，starting with $q_0(x)=p(x)$ 并且每一步都在提高。近似$p(x)H(x)$的迭代公式为<br>$$<br>q</em>{i+1}(x)= \operatorname{argmin}<em>{q</em>{i+1}(x)} -\mathbb E_{x\sim q_i(x)} \left[\frac{p(x)}{q_i(x)}H(x) \log q_{i+1}(x)\right]<br>$$<br>In RL, </p>
<p>首先，replace $H(x)$ with an indicator function. 也就是说function值为1 当reward of this episode 高于threshold；值为0如果reward小于。我们的policy update 就变成了<br>$$<br>\pi_{i+1}(a|s)= \operatorname{argmin}<em>{\pi</em>{i+1}} -\mathbb E_{z\sim\pi_{i}(a|s)}  \left[R(z)\geq \psi_i\right] \log \pi_{i+1}(a|s)<br>$$<br>意思是，用我们现在的policy来sample episodes， 然后minimize the negative log likelihood of the most successful samples and policy.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xiaoxue Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="199" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{&quot;enable&quot;:true,&quot;tags&quot;:&quot;none&quot;,&quot;single_dollars&quot;:true,&quot;cjk_width&quot;:0.9,&quot;normal_width&quot;:0.6,&quot;append_css&quot;:true,&quot;js&quot;:&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mathjax@3.1.4&#x2F;es5&#x2F;tex-mml-chtml.js&quot;}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
